{"href":"head.html","title":"Holding a Program in One's Head","content":"<font face=\"verdana\" size=\"2\">August 2007<br/><br/>A good programmer working intensively on his own code can hold it\nin his mind the way a mathematician holds a problem he's working\non.  Mathematicians don't answer questions by working them out on\npaper the way schoolchildren are taught to.  They do more in their\nheads: they try to understand a problem space well enough that they\ncan walk around it the way you can walk around the memory of the\nhouse you grew up in.  At its best programming is the same.  You\nhold the whole program in your head, and you can manipulate it at\nwill.<br/><br/>That's particularly valuable at the start of a project, because\ninitially the most important thing is to be able to change what\nyou're doing.  Not just to solve the problem in a different way,\nbut to change the problem you're solving.<br/><br/>Your code is your understanding of the problem you're exploring.\nSo it's only when you have your code in your head that you really\nunderstand the problem.<br/><br/>It's not easy to get a program into your head.  If you leave a\nproject for a few months, it can take days to really understand it\nagain when you return to it.  Even when you're actively working on\na program it can take half an hour to load into your head when you\nstart work each day.  And that's in the best case.  Ordinary\nprogrammers working in typical office conditions never enter this\nmode.  Or to put it more dramatically, ordinary programmers working\nin typical office conditions never really understand the problems\nthey're solving.<br/><br/>Even the best programmers don't always have the whole program they're\nworking on loaded into their heads.   But there are things you can\ndo to help:<br/><br/><ol>\n<li> <b>Avoid distractions.</b>  Distractions are bad for many types of work,\n   but especially bad for programming, because programmers tend to\n   operate at the limit of the detail they can handle.<br/><br/>The danger of a distraction depends not on how long it is, but\n   on how much it scrambles your brain.  A programmer can leave the\n   office and go and get a sandwich without losing the code in his\n   head.  But the wrong kind of interruption can wipe your brain\n   in 30 seconds.<br/><br/>Oddly enough, scheduled distractions may be worse than unscheduled\n   ones.  If you know you have a meeting in an hour, you don't even\n   start working on something hard.<br/><br/><li> <b>Work in long stretches.</b>  Since there's a fixed cost each time\n   you start working on a program, it's more efficient to work in\n   a few long sessions than many short ones.  There will of course\n   come a point where you get stupid because you're tired.  This\n   varies from person to person.  I've heard of people hacking for\n   36 hours straight, but the most I've ever been able to manage\n   is about 18, and I work best in chunks of no more than 12.<br/><br/>The optimum is not the limit you can physically endure.  There's\n   an advantage as well as a cost of breaking up a project.  Sometimes\n   when you return to a problem after a rest, you find your unconscious\n   mind has left an answer waiting for you.<br/><br/><li> <b>Use succinct languages.</b>  More \n   <a href=\"https://paulgraham.com/power.html\">powerful</a> programming languages\n   make programs shorter. And programmers seem to think of programs\n   at least partially in the language they're using to write them.\n   The more succinct the language, the shorter the program, and the\n   easier it is to load and keep in your head.<br/><br/>You can magnify the effect of a powerful language by using a\n   style called bottom-up programming, where you write programs in\n   multiple layers, the lower ones acting as programming languages\n   for those above.  If you do this right, you only have to keep\n   the topmost layer in your head.<br/><br/><li> <b>Keep rewriting your program.</b>  Rewriting a program often yields\n   a cleaner design.  But it would have advantages even if it didn't:\n   you have to understand a program completely to rewrite it, so\n   there is no better way to get one loaded into your head.<br/><br/><li> <b>Write rereadable code.</b>  All programmers know it's good to write\n   readable code.  But you yourself are the most important reader.\n   Especially in the beginning; a prototype is a conversation with\n   yourself.  And when writing for yourself you have different\n   priorities.  If you're writing for other people, you may not\n   want to make code too dense.  Some parts of a program may be\n   easiest to read if you spread things out, like an introductory \n   textbook.  Whereas if you're writing code to make it easy to reload \n   into your head, it may be best to go for brevity.<br/><br/><li> <b>Work in small groups.</b>  When you manipulate a program in your\n   head, your vision tends to stop at the edge of the code you own.\n   Other parts you don't understand as well, and more importantly,\n   can't take liberties with.  So the smaller the number of\n   programmers, the more completely a project can mutate.  If there's\n   just one programmer, as there often is at first, you can do\n   all-encompassing redesigns.<br/><br/><li> <b>Don't have multiple people editing the same piece of code.</b>  You\n   never understand other people's code as well as your own.  No\n   matter how thoroughly you've read it, you've only read it, not\n   written it.  So if a piece of code is written by multiple authors,\n   none of them understand it as well as a single author would.<br/><br/>And of course you can't safely redesign something other people\n   are working on.  It's not just that you'd have to ask permission.\n   You don't even let yourself think of such things.  Redesigning\n   code with several authors is like changing laws; redesigning\n   code you alone control is like seeing the other interpretation\n   of an ambiguous image.<br/><br/>If you want to put several people to work on a project, divide\n   it into components and give each to one person.<br/><br/><li> <b>Start small.</b>  A program gets easier to hold in your head as you\n   become familiar with it.  You can start to treat parts as black\n   boxes once you feel confident you've fully explored them.  But\n   when you first start working on a project, you're forced to see\n   everything.  If you start with too big a problem, you may never\n   quite be able to encompass it.  So if you need to write a big,\n   complex program, the best way to begin may not be to write a\n   spec for it, but to write a prototype that solves a subset of\n   the problem.  Whatever the advantages of planning, they're often\n   outweighed by the advantages of being able to keep a program in\n   your head.\n</li></li></li></li></li></li></li></li></ol>\nIt's striking how often programmers manage to hit all eight points\nby accident.  Someone has an idea for a new project, but because\nit's not officially sanctioned, he has to do it in off hours—which\nturn out to be more productive because there are no distractions.\nDriven by his enthusiasm for the new project he works on it for\nmany hours at a stretch.  Because it's initially just an\nexperiment, instead of a \"production\" language he uses a mere\n\"scripting\" language—which is in fact far more powerful.  He\ncompletely rewrites the program several times; that wouldn't be\njustifiable for an official project, but this is a labor of love\nand he wants it to be perfect.  And since no one is going to see\nit except him, he omits any comments except the note-to-self variety.\nHe works in a small group perforce, because he either hasn't told\nanyone else about the idea yet, or it seems so unpromising that no\none else is allowed to work on it.  Even if there is a group, they\ncouldn't have multiple people editing the same code, because it\nchanges too fast for that to be possible.  And the project starts\nsmall because the idea <i>is</i> small at first; he just has some cool\nhack he wants to try out.<br/><br/>Even more striking are the number of officially sanctioned projects\nthat manage to do <i>all eight things wrong</i>.  In fact, if you look at\nthe way software gets written in most organizations, it's almost\nas if they were deliberately trying to do things wrong. In a sense,\nthey are.  One of the defining qualities of organizations since\nthere have been such a thing is to treat individuals as interchangeable\nparts.  This works well for more parallelizable tasks, like fighting\nwars.  For most of history a well-drilled army of professional\nsoldiers could be counted on to beat an army of individual warriors,\nno matter how valorous.  But having ideas is not very parallelizable.\nAnd that's what programs are: ideas.<br/><br/>It's not merely true that organizations dislike the idea of depending\non individual genius, it's a tautology.  It's part of the definition\nof an organization not to.  Of our current concept of an organization,\nat least.<br/><br/>Maybe we could define a new kind of organization that combined the\nefforts of individuals without requiring them to be interchangeable.\nArguably a market is such a form of organization, though it may be\nmore accurate to describe a market as a degenerate case—as what\nyou get by default when organization isn't possible.<br/><br/>Probably the best we'll do is some kind of hack, like making the\nprogramming parts of an organization work differently from the rest.\nPerhaps the optimal solution is for big companies not even to try\nto develop ideas in house, but simply to \n<a href=\"https://paulgraham.com/hiring.html\">buy</a> them.  But regardless\nof what the solution turns out to be, the first step is to realize\nthere's a problem.  There is a contradiction in the very phrase\n\"software company.\"   The two words are pulling in opposite directions.\nAny good programmer in a large organization is going to be at odds\nwith it, because organizations are designed to prevent what\nprogrammers strive for.<br/><br/>Good programmers manage to get a lot done anyway.  \nBut often it\nrequires practically an act of rebellion against the organizations\nthat employ them.  Perhaps it will help if more people understand that the way\nprogrammers behave is driven by the demands of the work they do.\nIt's not because they're irresponsible that they work in long binges\nduring which they blow off all other obligations, plunge straight into\nprogramming instead of writing specs first, and rewrite code that\nalready works.  It's not because they're unfriendly that they prefer\nto work alone, or growl at people who pop their head in the door\nto say hello.  This apparently random collection of annoying habits\nhas a single explanation: the power of holding a program in one's\nhead.<br/><br/>Whether or not understanding this can help large organizations, it\ncan certainly help their competitors.  The weakest point in big\ncompanies is that they don't let individual programmers do great\nwork.  So if you're a little startup, this is the place to attack\nthem.  Take on the kind of problems that have to be solved in one\nbig brain.<br/><br/><br/><br/><br/><br/>\n<b>Thanks</b> to Sam Altman, David Greenspan, Aaron Iba, Jessica Livingston,\nRobert Morris, Peter Norvig, Lisa Randall, Emmett Shear, Sergei Tsarev,\nand Stephen Wolfram for reading drafts of this.<br/><br/></font>","date":"2007-08-01T00:00:00Z"}