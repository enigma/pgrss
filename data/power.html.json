{"href":"power.html","title":"Succinctness is Power","content":"<font face=\"verdana\" size=\"2\">May 2002<br/><br/><table cellpadding=\"6\" cellspacing=\"0\" width=\"410\">\n<tr><td bgcolor=\"#ffffdd\">\n<table cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n<tr><td bgcolor=\"#ffffdd\"><font size=\"2\">\n\"The quantity of meaning compressed into a small space by \nalgebraic signs, is another circumstance that facilitates \nthe reasonings we are accustomed to carry on by their aid.\"<br/><br/>- Charles Babbage, quoted in Iverson's Turing Award Lecture\n</font>\n</td></tr></table>\n</td></tr></table><br/><br/>\nIn the discussion about issues raised by <a href=\"icad.html\">Revenge \nof the Nerds</a> on the LL1 mailing list, Paul Prescod wrote\nsomething that stuck in my mind.\n<blockquote>\nPython's goal is regularity and readability, not succinctness.\n</blockquote>\nOn the face of it, this seems a rather damning thing to claim about a \nprogramming language.  As far as I can tell, succinctness = power.\nIf so, then substituting, we get\n<blockquote>\nPython's goal is regularity and readability, not power.\n</blockquote>\nand this doesn't seem a tradeoff (if it <i>is</i> a tradeoff)\nthat you'd want to make. \nIt's not far from saying that Python's goal is not to be effective \nas a programming language.<br/><br/>Does succinctness = power?  This seems to me an important question,\nmaybe the most important question for anyone interested in\nlanguage design, and one that it would be useful to confront\ndirectly.  I don't feel sure yet that the answer is a simple yes, but it seems \na good hypothesis to begin with.<br/><br/><b>Hypothesis</b><br/><br/>My hypothesis is that succinctness is power, or is close enough\nthat except in pathological examples you can treat them as \nidentical.<br/><br/>It seems to me that succinctness is what programming languages are \n<i>for.</i>  Computers would be just as happy to be told what to\ndo directly in machine language.  I think that the main\nreason we take the trouble to develop high-level languages is to\nget leverage, so that we can say (and more importantly, think)\nin 10 lines of a high-level language what would require 1000\nlines of machine language.  In other words,\nthe main point of high-level languages is to make source code smaller.<br/><br/>If smaller source code is the purpose of high-level languages, and\nthe power of something is how well it achieves its purpose, then\nthe measure of the power of a programming language is how small it\nmakes your programs.<br/><br/>Conversely, a language that doesn't make your programs small is\ndoing a bad job of what programming languages are supposed to\ndo, like a knife that doesn't cut well, or printing that's illegible.\n<!-- (There are niches for both of these, e.g. plastic knives made for\nchildren, or the way warning messages are printed on cigarette\npackages, but I think few languages want to be in such a niche.) --><br/><br/><b>Metrics</b><br/><br/>Small in what sense though?  The most common measure of code size is\nlines of code.  But I think that this metric is the most common because\nit is the easiest to measure.  I don't think anyone really believes\nit is the true test of the length of a program. Different\nlanguages have different conventions for how much you should put\non a line; in C a lot of lines have nothing on them but a delimiter or two.<br/><br/>Another easy test is the number of characters in a \nprogram, but this is not very good either; some languages (Perl,\nfor example) just\nuse shorter identifiers than others.<br/><br/>I think a better measure of the size of a program would be the \nnumber of elements, where an element is anything that\nwould be a distinct node if you drew a tree representing the \nsource code. The name of\na variable or function is an element; \nan integer or a floating-point number is an element;\na segment of literal text is an element;\nan element of a pattern, or a format directive, is an element;\na new block is an element.  There are borderline cases\n(is -5 two elements or one?) but I think most of them are the\nsame for every language, so they don't affect comparisons much.<br/><br/>This metric needs fleshing out, and\nit could require interpretation in the case of specific languages,\nbut I think it tries to measure the right thing, which is the \nnumber of parts a program has.  I think the tree you'd draw in this\nexercise is what you have to make in your head in order to\nconceive of the program, and so its size is proportionate to the\namount of work you have to do to write or read it.<br/><br/><b>Design</b><br/><br/>This kind of metric would allow us to compare different languages,\nbut that is not, at least for me, its main value.  The main value\nof the succinctness test is as a guide in <i>designing</i> languages.\nThe most useful comparison between languages is between two\npotential variants of the same language.  What can I do in the\nlanguage to make programs shorter?<br/><br/>If the conceptual load of\na program is proportionate to its complexity, and a given programmer\ncan tolerate a fixed conceptual load, then this is the same as asking,\nwhat can I do to enable programmers to get the most done?  And\nthat seems to me identical to asking, how can I design a good\nlanguage?<br/><br/>(Incidentally, nothing makes it more patently obvious that the old\nchestnut \"all languages are equivalent\" is false than designing\nlanguages.  When you are designing a new language, you're <i>constantly</i>\ncomparing two languages-- the language if I did x, and if I didn't-- to\ndecide which is better.  If this were really a meaningless question,\nyou might as well flip a coin.)<br/><br/>Aiming for succinctness seems a good way to find new ideas.\nIf you can do something that makes many\ndifferent programs shorter, it is probably not a coincidence: you have \nprobably discovered a useful new abstraction.  You might even be\nable to write a program to help by searching\nsource code for repeated patterns.  Among other languages, those\nwith a reputation for succinctness would be the ones to look to for\nnew ideas: Forth, Joy, Icon.<br/><br/><b>Comparison</b><br/><br/>The first person to write about these issues, as far as I know, was\nFred Brooks in the <i>Mythical Man Month</i>.  He wrote\nthat programmers seemed to generate about the same\namount of code per day regardless of the language.\nWhen I first read this in my early twenties,\nit was a big surprise to me and seemed to have huge implications.\nIt meant that (a) the only way to get software written faster was to\nuse a more succinct language, and (b) someone who took the\ntrouble to do this could leave competitors who didn't in the dust.<br/><br/>Brooks' hypothesis, if it's true, seems to be at the very heart of hacking.\nIn the years since, I've paid close attention to any evidence I could\nget on the question, from formal studies to anecdotes about individual\nprojects.   I have seen nothing to contradict him.<br/><br/>I have not yet seen evidence that seemed to me conclusive,\nand I don't expect to.  Studies\nlike Lutz Prechelt's comparison of programming languages, while\ngenerating the kind of results I expected, tend to use problems that\nare too short to be meaningful tests.  A better test of a language is\nwhat happens in programs that take a month to write.  And the only\nreal test, if you believe as I do that the main purpose of a language\nis to be good to think in (rather than just to tell a computer what to\ndo once you've thought of it) is what new things you can write in it.\nSo any language comparison where\nyou have to meet a predefined spec is testing slightly the wrong\nthing.<br/><br/>The true test of a language is how well you can discover\nand solve new problems, not\nhow well you can use it to solve a problem someone else has\nalready formulated.  These two are quite different criteria.\nIn art, mediums like embroidery and mosaic work well if you\nknow beforehand what you want to make, but are absolutely lousy if\nyou don't.  When you want to discover the image as you make it--\nas you have to do with anything as complex as an image of a\nperson, for example-- you need to use a more fluid medium like pencil or\nink wash or oil paint.  And indeed, the way tapestries and mosaics are made in\npractice is to make a painting first, then copy it.  (The word\n\"cartoon\" was originally used to describe a painting intended for\nthis purpose).<br/><br/>What this means is that we are never likely to have accurate comparisons\nof the relative power of programming languages.  We'll have precise\ncomparisons, but not accurate ones.  In particular, explicit studies\nfor the purpose of comparing languages,\nbecause they will probably use small problems, and will necessarily use\npredefined problems, will tend to underestimate the power of the\nmore powerful languages.<br/><br/>Reports from the field, though they will necessarily be less precise than\n\"scientific\" studies, are likely to be more meaningful.  For example, \nUlf Wiger of Ericsson did a \n<a href=\"http://www.erlang.se/publications/Ulf_Wiger.pdf\">study</a> that \nconcluded that Erlang was 4-10x\nmore succinct than C++, and proportionately faster to develop \nsoftware in:\n<blockquote>\nComparisons between Ericsson-internal development projects indicate\nsimilar line/hour productivity, including all phases of software development,\nrather independently of which language (Erlang, PLEX, C, C++, or Java)\nwas used.  What differentiates the different languages then becomes source\ncode volume.\n</blockquote>\n The study also deals explictly with a point that was \nonly implicit in Brooks' book (since he measured lines of debugged code):\nprograms written in more powerful languages tend to have fewer bugs.\nThat becomes an end in itself, possibly more important than programmer\nproductivity, in applications like network switches.<br/><br/><b>The Taste Test</b><br/><br/>Ultimately, I think you have to go with your gut.  What does it feel\nlike to program in the language?  I think the way to find (or design)\nthe best language is to become hypersensitive to how well a language\nlets you think, then choose/design the language that feels best.  If\nsome language feature is awkward or restricting, don't worry, you'll\nknow about it.<br/><br/>Such hypersensitivity will come at a cost.  You'll find that you can't\n<i>stand</i> programming in clumsy languages.   I find it unbearably\nrestrictive to program in languages without macros, just as someone used\nto dynamic typing finds it unbearably restrictive to have to go back to\nprogramming in a language where you have to declare the type of\nevery variable, and can't make a list of objects of different types.\n<!-- (It's like one of those nightmares where you have to go back to \nhigh school.) --><br/><br/>I'm not the only one.  I know many Lisp hackers that this has happened\nto.  In fact, the most accurate measure of the relative power of programming\nlanguages might be the percentage of people who know the language\nwho will take any job where they get to use that language, regardless\nof the application domain.<br/><br/><b>Restrictiveness</b><br/><br/>I think most hackers know what it means for a language to feel restrictive.\nWhat's happening when you feel that?  I think it's the same feeling\nyou get when the street you want to take is blocked off, and you have to\ntake a long detour to get where you wanted to go.  There is something\nyou want to say, and the language won't let you.<br/><br/>What's really going on here, I think, is that a restrictive language is\none that isn't succinct enough.  The problem is not simply that you can't\nsay what you planned to.  It's that the detour the language makes you\ntake is <i>longer.</i>  Try this thought experiment.  Suppose there were\nsome program you wanted to write, and the language wouldn't let you\nexpress it the way you planned to, but instead forced you to write the\nprogram in some other way that was <i>shorter.</i>  For me at least,\nthat wouldn't feel very restrictive.  It would be like the street you\nwanted to take being blocked off, and the policeman at the \nintersection directing you to a shortcut instead of a detour.  Great!<br/><br/>I think most (ninety percent?) of \nthe feeling of restrictiveness comes from being forced to make the program\nyou write in the language longer than one you have in your head.\nRestrictiveness is mostly lack of succinctness.\nSo when a language feels restrictive, what that (mostly) means is that it isn't\nsuccinct enough, and when a language isn't succinct, it will\nfeel restrictive.<br/><br/><b>Readability</b><br/><br/>The quote I began with mentions two other qualities, regularity and\nreadability.  I'm not sure what regularity is, or what advantage, \nif any, code that is regular and readable has over code that is merely\nreadable.  But I think I know what is meant by readability, and I think\nit is also related to succinctness.<br/><br/>We have to be careful here to distinguish between the readability of\nan individual line of code and the readability of the whole program.\nIt's the second that matters.  I agree that a line of Basic is likely to be\nmore readable than a line of Lisp.  But a program written in Basic is\nis going to have more lines than the same program written in\nLisp (especially once you cross over into Greenspunland). The\ntotal effort of reading the Basic program will surely be greater.\n<blockquote>\ntotal effort  = effort per line x number of lines\n</blockquote>\nI'm not as sure that readability is directly proportionate to succinctness\nas I am that power is, but certainly succinctness is a factor \n(in the mathematical sense; see equation above) in readability.\nSo it may not even be meaningful to say that the goal of a language is\nreadability, not succinctness; it could be like saying the goal was readability,\nnot readability.<br/><br/>What readability-per-line does mean, to the user encountering the language\nfor the first time, is that source code will <i>look unthreatening</i>.  So\nreadability-per-line\ncould be a good marketing decision, even if it is a bad design\ndecision.  It's isomorphic to the very successful technique of letting\npeople pay in installments: instead of frightening them with a high\nupfront price, you tell them the low monthly payment.  Installment plans\nare a net lose for the buyer, though, as mere readability-per-line probably\nis for the programmer.\nThe buyer is going to make a <i>lot</i> of those low, low payments; and \nthe programmer is going to read a <i>lot</i> of those individually readable lines.<br/><br/>This tradeoff predates programming languages.  If you're used to reading\nnovels and newspaper articles, your first experience of reading a math\npaper can be dismaying.  It could take half an hour to read a single page.  \nAnd yet, I am pretty sure that the notation is not the problem, even though\nit may feel like it is.  The math paper is hard to read \nbecause the ideas are hard.  If you expressed the same ideas in prose\n(as mathematicians had to do before they evolved succinct notations),\nthey wouldn't be any easier to read, because the paper would grow to the\nsize of a book.<br/><br/><b>To What Extent?</b><br/><br/>A number of people have rejected\nthe idea that succinctness = power.  I think it would be more useful, instead\nof simply arguing that they are the same or aren't, to ask:\nto what <i>extent</i> does succinctness = power?\nBecause clearly succinctness is\na large part of what higher-level languages are for.  If it is not all they're\nfor, then what else are they for, and how important, relatively, are these\nother functions?<br/><br/>I'm not proposing this just to make the debate more civilized.  I really\nwant to know the answer.  When, if ever,  is a language too succinct for \nits own good?<br/><br/>The hypothesis I began with was that, except in pathological examples,\nI thought succinctness could be considered identical with power.  What\nI meant was that in any language anyone would design, they\nwould be identical, but that if someone wanted to design a language\nexplicitly to disprove this hypothesis, they could probably do it.  I'm\nnot even sure of that, actually.<br/><br/><b>Languages, not Programs</b><br/><br/>We should be clear that we are talking about the succinctness\nof languages, not of individual programs.\nIt certainly is possible for individual programs to be written too densely.<br/><br/>I wrote about this in <a href=\"onlisp.html\">On Lisp</a>. A complex macro\nmay have to save many times its own length to be justified.  If writing\nsome hairy macro could save you ten lines of code every time you use it,\nand the macro is itself ten lines of code, then you get a net saving in\nlines if you use it more than once.  But that could still be a bad move,\nbecause macro definitions are harder to read than ordinary code.  You \nmight have to use the macro ten or twenty times before it yielded a net\nimprovement in readability.<br/><br/>I'm sure every language has such tradeoffs (though I suspect the stakes\nget higher as the language gets more powerful).  Every programmer must\nhave seen code that some clever person has made marginally shorter\nby using dubious programming tricks.<br/><br/>So there is no argument about that-- at least, not from me.  Individual\nprograms can certainly be too succinct for their own good.  The question\nis, can a language be?  Can a language compel programmers to write\ncode that's short (in elements) at the expense of overall readability?<br/><br/>One reason it's hard to imagine a language being too succinct is that if\nthere were some excessively compact way to phrase something, there would\nprobably also be a longer way.  For example, if you felt Lisp programs using\na lot of macros or higher-order functions were too dense,  you could, if you\npreferred, write code that was isomorphic to Pascal.  If you\ndon't want to express factorial in Arc as a call to a higher-order function\n<font face=\"courier\"><xmp>\n(rec zero 1 * 1-)\n</xmp></font>\nyou can also write out a recursive definition:\n<font face=\"courier\"><xmp>\n(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))\n</xmp></font>\nThough I can't off the top of my head think of any examples, I am interested\nin the question of whether a language could be too succinct.  Are there languages \nthat force you to write code in a way that is crabbed and incomprehensible?\nIf anyone has examples, I would be very interested to see them.<br/><br/>(Reminder: What I'm looking for are programs that are very dense according\nto the metric of \"elements\" sketched above, not merely programs that are\nshort because delimiters can be omitted and everything has a one-character name.)<br/><br/>\n<br/><br><br/></br></font>","date":"2002-05-01T00:00:00Z"}