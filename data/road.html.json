{"href":"road.html","title":"The Other Road Ahead","content":"<font face=\"verdana\" size=\"2\">September 2001<br/><br/><i>\n(This article explains why much of the next generation of software\nmay be server-based, what that will mean for programmers,\nand why this new kind of software is a great opportunity for startups.\nIt's derived from a talk at BBN Labs.)\n</i><br/><br/>In the summer of 1995, my friend Robert Morris and I decided to\nstart a startup.  The PR campaign leading up to Netscape's IPO was\nrunning full blast then, and there was a lot of talk in the press\nabout online commerce.  At the time there might have been thirty\nactual stores on the Web, all made by hand.  If there were going\nto be a lot of online stores, there would need to be software for making\nthem, so we decided to write some.<br/><br/>For the first week or so we intended to make this an ordinary   \ndesktop application.  Then one day we had the idea of making the\nsoftware run on our Web server, using the browser as an\ninterface.  We tried rewriting the software to work over\nthe Web, and it was clear that this was the way to go.\nIf we wrote our software to run on the server, it would be a lot easier\nfor the users and for us as well.<br/><br/>This turned out to be a good plan.  Now, as \n<a href=\"http://store.yahoo.com\">Yahoo Store</a>, this\nsoftware is the most popular online store builder, with\nabout 14,000 users.<br/><br/>When we started Viaweb, hardly anyone understood what we meant when\nwe said that the software ran on the server.  It was not until\nHotmail was launched a year later that people started to get it.\nNow everyone knows that this is a valid approach.  There is\na name now for what we were: an Application Service Provider,\nor ASP.<br/><br/>I think that a lot of the next generation of software will be\nwritten on this model.  Even Microsoft, who have the most to\nlose, seem to see the inevitablity of moving some things off\nthe desktop. If software moves\noff the desktop and onto servers, it will mean a very different\nworld for developers.  This article describes the surprising\nthings we saw, as some of the first visitors to this new world.\nTo the extent software does move onto\nservers, what I'm describing here is the future.<br/><br/><b>The Next Thing?</b><br/><br/>When we look back on the desktop software era, I think we'll marvel\nat the inconveniences people put up with, just as we marvel now at\nwhat early car owners put up with.  For the first twenty or thirty\nyears, you had to be a car expert to own a car.  But cars were such\na big win that lots of people who weren't car experts wanted to\nhave them as well.<br/><br/>Computers are in this phase now.  When you own a desktop computer,\nyou end up learning a lot more than you wanted to know about what's\nhappening inside it.  But more than half the households in the US\nown one.  My mother has a computer that she uses for email and for\nkeeping accounts.  About a year ago she was alarmed to receive a\nletter from Apple, offering her a discount on a new version of the\noperating system.  There's something wrong when a sixty-five year\nold woman who wants to use a computer for email and accounts has\nto think about installing new operating systems.  Ordinary users\nshouldn't even know the words \"operating system,\" much less \"device\ndriver\" or \"patch.\"<br/><br/>There is now another way to deliver software that will save users\nfrom becoming system administrators.  Web-based applications are\nprograms that run on Web servers and use Web pages as the user\ninterface.  For the average user this new kind of software will be\neasier, cheaper, more mobile, more reliable, and often more powerful\nthan desktop software.<br/><br/>With Web-based software, most users won't have to think about\nanything except the applications they use.  All the messy, changing\nstuff will be sitting on a server somewhere, maintained by the kind\nof people who are good at that kind of thing.  And so you won't\nordinarily need a computer, per se, to use software.  All you'll\nneed will be something with a keyboard, a screen, and a Web browser.\nMaybe it will have wireless Internet access.  Maybe it will also\nbe your cell phone.  Whatever it is, it will be consumer electronics:\nsomething that costs about $200, and that people choose mostly\nbased on how the case looks.  You'll pay more for Internet services\nthan you do for the hardware, just as you do now with telephones. [1]<br/><br/>It will take about a tenth of a second for a click to get to the\nserver and back, so users of heavily interactive software, like\nPhotoshop, will still want to have the computations happening on\nthe desktop.  But if you look at the kind of things most people\nuse computers for, a tenth of a second latency would not be a\nproblem.  My mother doesn't really need a desktop computer, and\nthere are a lot of people like her.<br/><br/><b>The Win for Users</b><br/><br/>Near my house there is a car with a bumper sticker that reads \"death\nbefore inconvenience.\"  Most people, most of the time, will take\nwhatever choice requires least work.  If Web-based software wins,\nit will be because it's more convenient.  And it looks as if it\nwill be, for users and developers both.<br/><br/>To use a purely Web-based application, all you need is a browser\nconnected to the Internet.  So you can use a Web-based application\nanywhere.  When you install software on your desktop computer, you\ncan only use it on that computer.  Worse still, your files are\ntrapped on that computer.  The inconvenience of this model becomes\nmore and more evident as people get used to networks.<br/><br/>The thin end of the wedge here was Web-based email.  Millions of\npeople now realize that you should have access to email messages\nno matter where you are.  And if you can see your email, why not\nyour calendar?  \nIf you can discuss a document with your colleagues,\nwhy can't you edit it?  Why should any of your data be trapped on\nsome computer sitting on a faraway desk?<br/><br/>The whole idea of \"your computer\" is going away, and being replaced\nwith \"your data.\"  You should be able to get at your data from any\ncomputer.  Or rather, any client, and a client doesn't have to be\na computer.<br/><br/>Clients shouldn't store data; they should be like telephones.  In\nfact they may become telephones, or vice versa.  And as clients\nget smaller, you have another reason not to keep your data on them:\nsomething you carry around with you can be lost or stolen.   Leaving\nyour PDA in a taxi is like a disk crash, except that your data is\nhanded to <a href=\"http://news.zdnet.co.uk/business/0,39020645,2077931,00.htm\">someone else</a> \ninstead of being vaporized.<br/><br/>With purely Web-based software, neither your data nor the applications\nare kept on the client.  So you don't have to install anything to\nuse it.  And when there's no installation, you don't have to worry\nabout installation going wrong.  There can't be incompatibilities\nbetween the application and your operating system, because the\nsoftware doesn't run on your operating system.<br/><br/>Because it needs no installation, it will be easy, and common, to\ntry Web-based software before you \"buy\" it.  You should expect to\nbe able to test-drive any Web-based application for free, just by\ngoing to the site where it's offered.  At Viaweb our whole site\nwas like a big arrow pointing users to the test drive.<br/><br/>After trying the demo, signing up for the service should require\nnothing more than filling out a brief form (the briefer the better).\nAnd that should be the last work the user has to do.  With Web-based\nsoftware, you should get new releases without paying extra, or\ndoing any work, or possibly even knowing about it.<br/><br/>Upgrades won't be the big shocks they are now.  Over time applications\nwill quietly grow more powerful.  This will take some effort on\nthe part of the developers.  They will have to design software so\nthat it can be updated without confusing the users.  That's a new\nproblem, but there are ways to solve it.<br/><br/>With Web-based applications, everyone uses the same version, and\nbugs can be fixed as soon as they're discovered.  So Web-based\nsoftware should have far fewer bugs than desktop software.  At\nViaweb, I doubt we ever had ten known bugs at any one time.  That's\norders of magnitude better than desktop software.<br/><br/>Web-based applications can be used by several people at the same\ntime.  This is an obvious win for collaborative applications, but\nI bet users will start to want this in most applications once they\nrealize it's possible.  It will often be useful to let two people\nedit the same document, for example.  Viaweb let multiple users\nedit a site simultaneously, more because that was the right way to\nwrite the software than because we expected users to want to, but\nit turned out that many did.<br/><br/>When you use a Web-based application, your data will be safer.\nDisk crashes won't be a thing of the past, but users won't hear\nabout them anymore.  They'll happen within server farms.  And\ncompanies offering Web-based applications will actually do backups--\nnot only because they'll have real system administrators worrying\nabout such things, but because an ASP that does lose people's data\nwill be in big, big trouble.  When people lose their own data in\na disk crash, they can't get that mad, because they only have\nthemselves to be mad at.  When a company loses their data for them,\nthey'll get a lot madder.<br/><br/>Finally, Web-based software should be less vulnerable to viruses.\nIf the client doesn't run anything except a browser, there's less\nchance of running viruses, and no data locally to damage.  And a\nprogram that attacked the servers themselves should find them very\nwell defended. [2]<br/><br/>For users, Web-based software will be <i>less stressful.</i>  I think if\nyou looked inside the average Windows user you'd find a huge and\npretty much untapped desire for software meeting that description.\nUnleashed, it could be a powerful force.<br/><br/><b>City of Code</b><br/><br/>To developers, the most conspicuous difference between Web-based\nand desktop software is that a Web-based application is not a single\npiece of code.  It will be a collection of programs of different\ntypes rather than a single big binary.  And so designing Web-based\nsoftware is like desiging a city rather than a building: as well\nas buildings you need roads, street signs, utilities, police and\nfire departments, and plans for both growth and various kinds of\ndisasters.<br/><br/>At Viaweb, software included fairly big applications that users\ntalked to directly, programs that those programs used, programs\nthat ran constantly in the background looking for problems, programs\nthat tried to restart things if they broke, programs that ran\noccasionally to compile statistics or build indexes for searches,\nprograms we ran explicitly to garbage-collect resources or to move\nor restore data, programs that pretended to be users (to measure\nperformance or expose bugs), programs for diagnosing network\ntroubles, programs for doing backups, interfaces to outside services,\nsoftware that drove an impressive collection of dials displaying\nreal-time server statistics (a hit with visitors, but indispensable\nfor us too), modifications (including bug fixes) to open-source\nsoftware, and a great many configuration files and settings.  Trevor\nBlackwell wrote a spectacular program for moving stores to new\nservers across the country, without shutting them down, after we\nwere bought by Yahoo. Programs paged us, sent faxes and email to\nusers, conducted transactions with credit card processors, and\ntalked to one another through sockets, pipes, http requests, ssh,\nudp packets, shared memory, and files.  Some of Viaweb even consisted\nof the absence of programs, since one of the keys to Unix security\nis not to run unnecessary utilities that people might use to break\ninto your servers.<br/><br/>It did not end with software.  We spent a lot of time thinking\nabout server configurations.  We built the servers ourselves, from\ncomponents-- partly to save money, and partly to get exactly what\nwe wanted.  We had to think about whether our upstream ISP had fast\nenough connections to all the backbones.  We serially  \n<a href=\"http://groups.google.com/groups?selm=6hdipo%243o0%241%40FreeBSD.csie.NCTU.edu.tw\">dated</a>\nRAID suppliers.<br/><br/>But hardware is not just something to worry about.  When you control\nit you can do more for users.  With a desktop application, you can\nspecify certain minimum hardware, but you can't add more.  If you\nadminister the servers, you can in one step enable all your users\nto page people, or send faxes, or send commands by phone, or process\ncredit cards, etc, just by installing the relevant hardware.  We\nalways looked for new ways to add features with hardware, not just\nbecause it pleased users, but also as a way to distinguish ourselves\nfrom competitors who (either because they sold desktop software,\nor resold Web-based applications through ISPs) didn't have direct\ncontrol over the hardware.<br/><br/>Because the software in a Web-based application will be a collection\nof programs rather than a single binary, it can be written in any\nnumber of different languages.  When you're writing desktop software,\nyou're practically forced to write the application in the same\nlanguage as the underlying operating system-- meaning C and C++.\nAnd so these languages (especially among nontechnical people like\nmanagers and VCs) got to be considered as the languages for \"serious\"\nsoftware development.  But that was just an artifact of the way\ndesktop software had to be delivered.  For server-based software\nyou can use any language you want. [3]  Today a lot of the top\nhackers are using languages far removed from C and C++:  Perl,\nPython, and even Lisp.<br/><br/>With server-based software, no one can tell you what language to\nuse, because you control the whole system, right down to the\nhardware.  Different languages are good for different tasks.  You\ncan use whichever is best for each.  And when you have competitors,\n\"you can\" means \"you must\" (we'll return to this later), because\nif you don't take advantage of this possibility, your competitors\nwill.<br/><br/>Most of our competitors used C and C++, and this made their software\nvisibly inferior because (among other things), they had no way\naround the statelessness of CGI scripts.  If you were going to\nchange something, all the changes had to happen on one page, with\nan Update button at the bottom.  As I've written elsewhere, by\nusing <a href=\"avg.html\">Lisp</a>, which many people still consider \na research language,\nwe could make the Viaweb editor behave more like desktop software.<br/><br/><b>Releases</b><br/><br/>One of the most important changes in this new world is the way you\ndo releases. In the desktop software business, doing a release is\na huge trauma, in which the whole company sweats and strains to\npush out a single, giant piece of code.  Obvious comparisons suggest\nthemselves, both to the process and the resulting product.<br/><br/>With server-based software, you can make changes almost as you\nwould in a program you were writing for yourself.  You release\nsoftware as a series of incremental changes instead of an occasional\nbig explosion. A typical desktop software company might do one or\ntwo releases a year.  At Viaweb we often did three to five releases\na day.<br/><br/>When you switch to this new model, you realize how much software\ndevelopment is affected by the way it is released.  Many of the\nnastiest problems you see in the desktop software business are due\nto catastrophic nature of releases.<br/><br/>When you release only one new version a year, you tend to deal with\nbugs wholesale.  Some time before the release date you assemble a\nnew version in which half the code has been torn out and replaced,\nintroducing countless bugs.  Then a squad of QA people step in and\nstart counting them, and the programmers work down the list, fixing\nthem.  They do not generally get to the end of the list, and indeed,\nno one is sure where the end is.  It's like fishing rubble out of\na pond.  You never really know what's happening inside the software.\nAt best you end up with a statistical sort of correctness.<br/><br/>With server-based software, most of the change is small and\nincremental.  That in itself is less likely to introduce bugs.  It\nalso means you know what to test most carefully when you're about\nto release software: the last thing you changed.  You end up with\na much firmer grip on the code.  As a general rule, you do know\nwhat's happening inside it.  You don't have the source code memorized,\nof course, but when you read the source you do it like a pilot\nscanning the instrument panel, not like a detective trying to\nunravel some mystery.<br/><br/>Desktop software breeds a certain fatalism about bugs.  You know\nthat you're shipping something loaded with bugs, and you've even\nset up mechanisms to compensate for it (e.g. patch releases).  So\nwhy worry about a few more?  Soon you're releasing whole features\nyou know are broken.  \n<a href=\"http://news.cnet.com/news/0-1006-200-5195914.html\">Apple</a> \ndid this earlier this year.  They felt\nunder pressure to release their new OS, whose release date had\nalready slipped four times, but some of the software (support for\nCDs and DVDs) wasn't ready. The solution?  They released the OS\nwithout the unfinished parts, and users will have to install them\nlater.<br/><br/>With Web-based software, you never have to release software before\nit works, and you can release it as soon as it does work.<br/><br/>The industry veteran may be thinking, it's a fine-sounding idea to\nsay that you never have to release software before it works, but\nwhat happens when you've promised to deliver a new version of your\nsoftware by a certain date?  With Web-based software, you wouldn't\nmake such a promise, because there are no versions.  Your software\nchanges gradually and continuously.  Some changes might be bigger\nthan others, but the idea of versions just doesn't naturally fit\nonto Web-based software.<br/><br/>If anyone remembers Viaweb this might sound odd, because we were\nalways announcing new versions.  This was done entirely for PR\npurposes.  The trade press, we learned, thinks in version numbers.\nThey will give you major coverage for a major release, meaning a\nnew first digit on the version number, and generally a paragraph\nat most for a point release, meaning a new digit after the decimal\npoint.<br/><br/>Some of our competitors were offering desktop software and actually\nhad version numbers.  And for these releases, the mere fact of\nwhich seemed to us evidence of their backwardness, they would get\nall kinds of publicity.  We didn't want to miss out, so we started\ngiving version numbers to our software too.  When we wanted some\npublicity, we'd make a list of all the features we'd added since\nthe last \"release,\" stick a new version number on the software,\nand issue a press release saying that the new version was available\nimmediately.  Amazingly, no one ever called us on it.<br/><br/>By the time we were bought, we had done this three times, so we\nwere on Version 4.  Version 4.1 if I remember correctly.  After\nViaweb became Yahoo Store, there was no longer such a desperate\nneed for publicity, so although the software continued to evolve,\nthe whole idea of version numbers was quietly dropped.<br/><br/><b>Bugs</b><br/><br/>The other major technical advantage of Web-based software is that\nyou can reproduce most bugs.  You have the users' data right there\non your disk.  If someone breaks your software, you don't have to\ntry to guess what's going on, as you would with desktop software:\nyou should be able to reproduce the error while they're on the\nphone with you.  You might even know about it already, if you have\ncode for noticing errors built into your application.<br/><br/>Web-based software gets used round the clock, so everything you do\nis immediately put through the wringer.  Bugs turn up quickly.<br/><br/>Software companies are sometimes accused of letting the users debug\ntheir software.  And that is just what I'm advocating.  For Web-based\nsoftware it's actually a good plan, because the bugs are fewer and\ntransient.  When you release software gradually you get far fewer\nbugs to start with.  And when you can reproduce errors and release\nchanges instantly, you can find and fix most bugs as soon as they\nappear.  We never had enough bugs at any one time to bother with\na formal bug-tracking system.<br/><br/>You should test changes before you release them, of course, so no\nmajor bugs should get released.  Those few that inevitably slip\nthrough will involve borderline cases and will only affect the few\nusers that encounter them before someone calls in to complain.  As\nlong as you fix bugs right away, the net effect, for the average\nuser, is far fewer bugs.  I doubt the average Viaweb user ever saw\na bug.<br/><br/>Fixing fresh bugs is easier than fixing old ones.  It's usually\nfairly quick to find a bug in code you just wrote.  When it turns\nup you often know what's wrong before you even look at the source,\nbecause you were already worrying about it subconsciously. Fixing\na bug in something you wrote six months ago (the average case if\nyou release once a year) is a lot more work.  And since you don't\nunderstand the code as well, you're more likely to fix it in an\nugly way, or even introduce more bugs. [4]<br/><br/>When you catch bugs early, you also get fewer compound bugs.\nCompound bugs are two separate bugs that interact:  you trip going\ndownstairs, and when you reach for the handrail it comes off in\nyour hand.  In software this kind of bug is the hardest to find,\nand also tends to have the worst consequences. [5]  The traditional\n\"break everything and then filter out the bugs\" approach inherently\nyields a lot of compound bugs.  And software that's released in a\nseries of small changes inherently tends not to. The floors are\nconstantly being swept clean of any loose objects that might later\nget stuck in something.<br/><br/>It helps if you use a technique called functional programming.\nFunctional programming means avoiding side-effects.  It's something\nyou're more likely to see in research papers than commercial\nsoftware, but for Web-based applications it turns out to be really\nuseful.  It's hard to write entire programs as purely functional\ncode, but you can write substantial chunks this way.  It makes\nthose parts of your software easier to test, because they have no\nstate, and that is very convenient in a situation where you are\nconstantly making and testing small modifications.  I wrote much\nof Viaweb's editor in this style, and we made our scripting language,\n<a href=\"http://store.yahoo.com/rtml.html\">RTML</a>, \na purely functional language.<br/><br/>People from the desktop software business will find this hard to\ncredit, but at Viaweb bugs became almost a game.  Since most released\nbugs involved borderline cases, the users who encountered them were\nlikely to be advanced users, pushing the envelope.  Advanced users\nare more forgiving about bugs, especially since you probably\nintroduced them in the course of adding some feature they were\nasking for.  In fact, because bugs were rare and you had to be\ndoing sophisticated things to see them, advanced users were often\nproud to catch one.  They would call support in a spirit more of\ntriumph than anger, as if they had scored points off us.<br/><br/><b>Support</b><br/><br/>When you can reproduce errors, it changes your approach to customer\nsupport.  At most software companies, support is offered as a way\nto make customers feel better.  They're either calling you about\na known bug, or they're just doing something wrong and you have to\nfigure out what.  In either case there's not much you can learn\nfrom them.  And so you tend to view support calls as a pain in the\nass that you want to isolate from your developers as much as\npossible.<br/><br/>This was not how things worked at Viaweb.  At Viaweb, support was\nfree, because we wanted to hear from customers.  If someone had a\nproblem, we wanted to know about it right away so that we could\nreproduce the error and release a fix.<br/><br/>So at Viaweb the developers were always in close contact with\nsupport.  The customer support people were about thirty feet away\nfrom the programmers, and knew that they could always interrupt\nanything with a report of a genuine bug.  We would leave a board\nmeeting to fix a serious bug.<br/><br/>Our approach to support made everyone happier.  The customers were\ndelighted.  Just imagine how it would feel to call a support line\nand be treated as someone bringing important news.  The customer\nsupport people liked it because it meant they could help the users,\ninstead of reading scripts to them.  And the programmers liked it\nbecause they could reproduce bugs instead of just hearing vague\nsecond-hand reports about them.<br/><br/>Our policy of fixing bugs on the fly changed the relationship\nbetween customer support people and hackers.  At most software\ncompanies, support people are underpaid human shields, and hackers\nare little copies of God the Father, creators of the world.  Whatever\nthe procedure for reporting bugs, it is likely to be one-directional:\nsupport people who hear about bugs fill out some form that eventually\ngets passed on (possibly via QA) to programmers, who put it on\ntheir list of things to do.  It was very different at Viaweb.\nWithin a minute of hearing about a bug from a customer, the support\npeople could be standing next to a programmer hearing him say \"Shit,\nyou're right, it's a bug.\" It delighted the support people to hear\nthat \"you're right\" from the hackers.  They used to bring us bugs\nwith the same expectant air as a cat bringing you a mouse it has\njust killed.   It also made them more careful in judging the\nseriousness of a bug, because now their honor was on the line.<br/><br/>After we were bought by Yahoo, the customer support people were\nmoved far away from the programmers.  It was only then that we\nrealized that they were effectively QA and to some extent marketing\nas well.  In addition to catching bugs, they were the keepers of\nthe knowledge of vaguer, buglike things, like features that confused\nusers. [6]  They were also a kind of proxy focus group; we could\nask them which of two new features users wanted more, and they were\nalways right.<br/><br/><b>Morale</b><br/><br/>Being able to release software immediately is a big motivator.\nOften as I was walking to work I would think of some change I wanted\nto make to the software, and do it that day.  This worked for bigger\nfeatures as well.  Even if something was going to take two weeks\nto write (few projects took longer), I knew I could see the effect\nin the software as soon as it was done.<br/><br/>If I'd had to wait a year for the next release, I would have shelved\nmost of these ideas, for a while at least.  The thing about ideas,\nthough, is that they lead to more ideas.  Have you ever noticed\nthat when you sit down to write something, half the ideas that end\nup in it are ones you thought of while writing it?  The same thing\nhappens with software.  Working to implement one idea gives you\nmore ideas.  So shelving an idea costs you not only that delay in\nimplementing it, but also all the ideas that implementing it would\nhave led to.  In fact, shelving an idea probably even inhibits new\nideas: as you start to think of some new feature, you catch sight\nof the shelf and think \"but I already have a lot of new things I\nwant to do for the next release.\"<br/><br/>What big companies do instead of implementing features is plan\nthem.  At Viaweb we sometimes ran into trouble on this account.\nInvestors and analysts would ask us what we had planned for the\nfuture.  The truthful answer would have been, we didn't have any\nplans.  We had general ideas about things we wanted to improve,\nbut if we knew how we would have done it already.  What were we\ngoing to do in the next six months? Whatever looked like the biggest\nwin.  I don't know if I ever dared give this answer, but that was\nthe truth.  Plans are just another word for ideas on the shelf.\nWhen we thought of good ideas, we implemented them.<br/><br/>At Viaweb, as at many software companies, most code had one definite\nowner.  But when you owned something you really owned it: no one\nexcept the owner of a piece of software had to approve (or even\nknow about) a release.  There was no protection against breakage\nexcept the fear of looking like an idiot to one's peers, and that\nwas more than enough.  I may have given the impression that we just\nblithely plowed forward writing code.  We did go fast, but we\nthought very carefully before we released software onto those\nservers.  And paying attention is more important to reliability\nthan moving slowly.  Because he pays close attention, a Navy pilot\ncan land a 40,000 lb. aircraft at 140 miles per hour on a pitching\ncarrier deck, at night, more safely than the average teenager can\ncut a bagel.<br/><br/>This way of writing software is a double-edged sword of course.\nIt works a lot better for a small team of good, trusted programmers\nthan it would for a big company of mediocre ones, where bad ideas\nare caught by committees instead of the people that had them.<br/><br/><b>Brooks in Reverse</b><br/><br/>Fortunately, Web-based software does require fewer programmers.\nI once worked for a medium-sized desktop software company that had\nover 100 people working in engineering as a whole.  Only 13 of\nthese were in product development.  All the rest were working on\nreleases, ports, and so on.  With Web-based software, all you need\n(at most) are the 13 people, because there are no releases, ports,\nand so on.<br/><br/>Viaweb was written by just three people. [7]  I was always under\npressure to hire more, because we wanted to get bought, and we knew\nthat buyers would have a hard time paying a high price for a company\nwith only three programmers.  (Solution:  we hired more, but created\nnew projects for them.)<br/><br/>When you can write software with fewer programmers, it saves you\nmore than money.  As Fred Brooks pointed out in <i>The Mythical\nMan-Month,</i> adding people to a project tends to slow it down.  The\nnumber of possible connections between developers grows exponentially\nwith the size of the group.  The larger the group, the more time\nthey'll spend in meetings negotiating how their software will work\ntogether, and the more bugs they'll get from unforeseen interactions.\nFortunately, this process also works in reverse: as groups get\nsmaller, software development gets exponentially more efficient.\nI can't remember the programmers at Viaweb ever having an actual\nmeeting.  We never had more to say at any one time than we could\nsay as we were walking to lunch.<br/><br/>If there is a downside here, it is that all the programmers have\nto be to some degree system administrators as well.  When you're\nhosting software, someone has to be watching the servers, and in\npractice the only people who can do this properly are the ones who\nwrote the software.  At Viaweb our system had so many components\nand changed so frequently that there was no definite border between\nsoftware and infrastructure.  Arbitrarily declaring such a border\nwould have constrained our design choices.  And so although we were\nconstantly hoping that one day (\"in a couple months\") everything\nwould be stable enough that we could hire someone whose job was\njust to worry about the servers, it never happened.<br/><br/>I don't think it could be any other way, as long as you're still\nactively developing the product.  Web-based software is never going\nto be something you write, check in, and go home.  It's a live\nthing, running on your servers right now.  A bad bug might not just\ncrash one user's process; it could crash them all.  If a bug in\nyour code corrupts some data on disk, you have to fix it.  And so\non.  We found that you don't have to watch the servers every minute\n(after the first year or so), but you definitely want to keep an\neye on things you've changed recently.  You don't release code late\nat night and then go home.<br/><br/><b>Watching Users</b><br/><br/>With server-based software, you're in closer touch with your code.\nYou can also be in closer touch with your users.  Intuit is famous\nfor introducing themselves to customers at retail stores and asking\nto follow them home.  If you've ever watched someone use your\nsoftware for the first time, you know what surprises must have\nawaited them.<br/><br/>Software should do what users think it will.  But you can't have\nany idea what users will be thinking, believe me, until you watch\nthem.  And server-based software gives you unprecedented information\nabout their behavior.  You're not limited to small, artificial\nfocus groups.  You can see every click made by every user.  You\nhave to consider carefully what you're going to look at, because\nyou don't want to violate users' privacy, but even the most general\nstatistical sampling can be very useful.<br/><br/>When you have the users on your server, you don't have to rely on\nbenchmarks, for example.  Benchmarks are simulated users.  With\nserver-based software, you can watch actual users.  To decide what\nto optimize, just log into a server and see what's consuming all\nthe CPU.  And you know when to stop optimizing too: we eventually\ngot the Viaweb editor to the point where it was memory-bound rather\nthan CPU-bound, and since there was nothing we could do to decrease\nthe size of users' data (well, nothing easy), we knew we might as\nwell stop there.<br/><br/>Efficiency matters for server-based software, because you're paying\nfor the hardware.  The number of users you can support per server\nis the divisor of your capital cost, so if you can make your software\nvery efficient you can undersell competitors and still make a\nprofit.  At Viaweb we got the capital cost per user down to about\n$5.  It would be less now, probably less than the cost of sending\nthem the first month's bill.  Hardware is free now, if your software\nis reasonably efficient.<br/><br/>Watching users can guide you in design as well as optimization.\nViaweb had a scripting language called RTML that let advanced users\ndefine their own page styles.  We found that RTML became a kind of\nsuggestion box, because users only used it when the predefined page\nstyles couldn't do what they wanted.  Originally the editor put\nbutton bars across the page, for example, but after a number of\nusers used RTML to put buttons down the left \n<a href=\"https://sep.turbifycdn.com/ca/I/paulgraham_1656_3563\">side</a>, \nwe made that an\noption (in fact the default) in the predefined page styles.<br/><br/>Finally, by watching users you can often tell when they're in\ntrouble.  And since the customer is always right, that's a sign of\nsomething you need to fix.  At Viaweb the key to getting users was\nthe online test drive.  It was not just a series of slides built\nby marketing people.  In our test drive, users actually used the\nsoftware.  It took about five minutes, and at the end of it they\nhad built a real, working store.<br/><br/><!--[The <a href=\"http://edit.store.yahoo.com/RT/SIGNUP-STORE\">test drive</a> \nis still online, but now\nthey make you fill out several forms, and don't tell you\nthat you've created a working store.  If you try the test\ndrive, here is how to find your store: if you choose foo as your\nstore id, the finished store will be at store.yahoo.com/foo.]\n-->\nThe test drive was the way we got nearly all our new users.  I\nthink it will be the same for most Web-based applications.   If\nusers can get through a test drive successfully, they'll like the\nproduct.  If they get confused or bored, they won't.  So anything\nwe could do to get more people through the test drive would increase\nour growth rate.<br/><br/>I studied click trails of people taking the test drive and found\nthat at a certain step they would get confused and click on the\nbrowser's Back button.  (If you try writing Web-based applications,\nyou'll find that the Back button becomes one of your most interesting\nphilosophical problems.) So I added a message at that point, telling\nusers that they were nearly finished, and reminding them not to\nclick on the Back button.  Another great thing about Web-based\nsoftware is that you get instant feedback from changes:  the number\nof people completing the test drive rose immediately from 60% to\n90%.  And since the number of new users was a function of the number\nof completed test drives, our revenue growth increased by 50%, just\nfrom that change.<br/><br/><b>Money</b><br/><br/>In the early 1990s I read an article in which someone said that\nsoftware was a subscription business.  At first this seemed a very\ncynical statement.  But later I realized that it reflects reality:\nsoftware development is an ongoing process.  I think it's cleaner\nif you openly charge subscription fees, instead of forcing people\nto keep buying and installing new versions so that they'll keep\npaying you.  And fortunately, subscriptions are the natural way to\nbill for Web-based applications.<br/><br/>Hosting applications is an area where companies will play a role\nthat is not likely to be filled by freeware.  Hosting applications\nis a lot of stress, and has real expenses.  No one is going to want\nto do it for free.<br/><br/>For companies, Web-based applications are an ideal source of revenue.\nInstead of starting each quarter with a blank slate, you have a\nrecurring revenue stream.  Because your software evolves gradually,\nyou don't have to worry that a new model will flop; there never\nneed be a new model, per se, and if you do something to the software\nthat users hate, you'll know right away.  You have no trouble with\nuncollectable bills; if someone won't pay you can just turn off\nthe service.  And there is no possibility of piracy.<br/><br/>That last \"advantage\" may turn out to be a problem.  Some amount\nof piracy is to the advantage of software companies.  If some user\nreally would not have bought your software at any price, you haven't\nlost anything if he uses a pirated copy.  In fact you gain, because\nhe is one more user helping to make your software the standard--\nor who might buy a copy later, when he graduates from high school.<br/><br/>When they can, companies like to do something called price\ndiscrimination, which means charging each customer as much as they\ncan afford. [8] Software is particularly suitable for price\ndiscrimination, because the marginal cost is close to zero.  This\nis why some software costs more to run on Suns than on Intel boxes:\na company that uses Suns is not interested in saving money and can\nsafely be charged more.  Piracy is effectively the lowest tier of\nprice discrimination.  I think that software companies understand\nthis and deliberately turn a blind eye to some kinds of piracy. [9] \nWith server-based software they are going to have to come up with \nsome other solution.<br/><br/>Web-based software sells well, especially in comparison to desktop\nsoftware, because it's easy to buy.  You might think that people\ndecide to buy something, and then buy it, as two separate steps.\nThat's what I thought before Viaweb, to the extent I thought about\nthe question at all.  In fact the second step can propagate back\ninto the first: if something is hard to buy, people will change\ntheir mind about whether they wanted it.  And vice versa: you'll\nsell more of something when it's easy to buy.  I buy more books\nbecause Amazon exists.  Web-based software is just about the easiest\nthing in the world to buy, especially if you have just done an\nonline demo.  Users should not have to do much more than enter a\ncredit card number.  (Make them do more at your peril.)<br/><br/>\nSometimes Web-based software is offered through ISPs acting as\nresellers.  This is a bad idea.  You have to be administering the\nservers, because you need to be constantly improving both hardware\nand software.  If you give up direct control of the servers, you\ngive up most of the advantages of developing Web-based applications.<br/><br/>Several of our competitors shot themselves in the foot this way--\nusually, I think, because they were overrun by suits who were\nexcited about this huge potential channel, and didn't realize that\nit would ruin the product they hoped to sell through it.  Selling\nWeb-based software through ISPs is like selling sushi through\nvending machines.<br/><br/><b>Customers</b><br/><br/>Who will the customers be?  At Viaweb they were initially individuals\nand smaller companies, and I think this will be the rule with\nWeb-based applications.  These are the users who are ready to try\nnew things, partly because they're more flexible, and partly because\nthey want the lower costs of new technology.<br/><br/>Web-based applications will often be the best thing for big companies\ntoo (though they'll be slow to realize it).  The best intranet is\nthe Internet.  If a company uses true Web-based applications, the\nsoftware will work better, the servers will be better administered,\nand employees will have access to the system from anywhere.<br/><br/>The argument against this approach usually hinges on security: if\naccess is easier for employees, it will be for bad guys too.  Some\nlarger merchants were reluctant to use Viaweb because they thought\ncustomers' credit card information would be safer on their own\nservers.  It was not easy to make this point diplomatically, but\nin fact the data was almost certainly safer in our hands than\ntheirs.  Who can hire better people to manage security, a technology\nstartup whose whole business is running servers, or a clothing\nretailer?  Not only did we have better people worrying about\nsecurity, we worried more about it.  If someone broke into the\nclothing retailer's servers, it would affect at most one merchant,\ncould probably be hushed up, and in the worst case might get one\nperson fired.  If someone broke into ours, it could affect thousands\nof merchants, would probably end up as news on CNet, and could put\nus out of business.<br/><br/>If you want to keep your money safe, do you keep it under your\nmattress at home, or put it in a bank? This argument applies to\nevery aspect of server administration:  not just security, but\nuptime, bandwidth, load management, backups, etc.  Our existence\ndepended on doing these things right.  Server problems were the\nbig no-no for us, like a dangerous toy would be for a toy maker,\nor a salmonella outbreak for a food processor.<br/><br/>A big company that uses Web-based applications is to that extent\noutsourcing IT.  Drastic as it sounds, I think this is generally\na good idea.  Companies are likely to get better service this way\nthan they would from in-house system administrators.  System\nadministrators can become cranky and unresponsive because they're\nnot directly exposed to competitive pressure:  a salesman has to\ndeal with customers, and a developer has to deal with competitors'\nsoftware, but a system administrator, like an old bachelor, has\nfew external forces to keep him in line. [10]  At Viaweb we had\nexternal forces in plenty to keep us in line. The people calling\nus were customers, not just co-workers.  If a server got wedged,\nwe jumped; just thinking about it gives me a jolt of adrenaline,\nyears later.<br/><br/>So Web-based applications will ordinarily be the right answer for\nbig companies too.  They will be the last to realize it, however,\njust as they were with desktop computers.  And partly for the same\nreason: it will be worth a lot of money to convince big companies\nthat they need something more expensive.<br/><br/>There is always a tendency for rich customers to buy expensive\nsolutions, even when cheap solutions are better, because the people\noffering expensive solutions can spend more to sell them.  At Viaweb\nwe were always up against this.  We lost several high-end merchants\nto Web consulting firms who convinced them they'd be better off if\nthey paid half a million dollars for a custom-made online store on\ntheir own server.  They were, as a rule, not better off, as more\nthan one discovered when Christmas shopping season came around and\nloads rose on their server.  Viaweb was a lot more sophisticated\nthan what most of these merchants got, but we couldn't afford to\ntell them.  At $300 a month, we couldn't afford to send a team of\nwell-dressed and authoritative-sounding people to make presentations\nto customers.<br/><br/>A large part of what big companies pay extra for is the cost of\nselling expensive things to them.  (If the Defense Department pays\na thousand dollars for toilet seats, it's partly because it costs\na lot to sell toilet seats for a thousand dollars.)  And this is\none reason intranet software will continue to thrive, even though\nit is probably a bad idea.  It's simply more expensive.  There is\nnothing you can do about this conundrum, so the best plan is to go\nfor the smaller customers first.  The rest will come in time.<br/><br/><b>Son of Server</b><br/><br/>Running software on the server is nothing new.  In fact it's the\nold model: mainframe applications are all server-based.  If\nserver-based software is such a good idea, why did it lose last\ntime?  Why did desktop computers eclipse mainframes?<br/><br/>At first desktop computers didn't look like much of a threat.  The\nfirst users were all hackers-- or hobbyists, as they were called\nthen.  They liked microcomputers because they were cheap.  For the\nfirst time, you could have your own computer.  The phrase \"personal\ncomputer\" is part of the language now, but when it was first used\nit had a deliberately audacious sound, like the phrase \"personal\nsatellite\" would today.<br/><br/>Why did desktop computers take over? I think it was because they\nhad better software.  And I think the reason microcomputer software\nwas better was that it could be written by small companies.<br/><br/>I don't think many people realize how fragile and tentative startups\nare in the earliest stage.  Many startups begin almost by accident--\nas a couple guys, either with day jobs or in school, writing a\nprototype of something that might, if it looks promising, turn into\na company. At this larval stage, any significant obstacle will stop\nthe startup dead in its tracks.  Writing mainframe software required\ntoo much commitment up front.  Development machines were expensive,\nand because the customers would be big companies, you'd need an\nimpressive-looking sales force to sell it to them.  Starting a\nstartup to write mainframe software would be a much more serious\nundertaking than just hacking something together on your Apple II\nin the evenings.  And so you didn't get a lot of startups writing\nmainframe applications.<br/><br/>The arrival of desktop computers inspired a lot of new software,\nbecause writing applications for them seemed an attainable goal to\nlarval startups.  Development was cheap, and the customers would\nbe individual people that you could reach through computer stores\nor even by mail-order.<br/><br/>The application that pushed desktop computers out into the mainstream\nwas <a href=\"http://www.bricklin.com/visicalc.htm\">VisiCalc</a>, the \nfirst spreadsheet.  It was written by two guys\nworking in an attic, and yet did things no mainframe software could\ndo. [11]  VisiCalc was such an advance, in its time, that people\nbought Apple IIs just to run it.  And this was the beginning of a\ntrend: desktop computers won because startups wrote software for\nthem.<br/><br/>It looks as if server-based software will be good this time around,\nbecause startups will write it.  Computers are so cheap now that\nyou can get started, as we did, using a desktop computer as a\nserver.  Inexpensive processors have eaten the workstation market\n(you rarely even hear the word now) and are most of the way through\nthe server market; Yahoo's servers, which deal with loads as high\nas any on the Internet, all have the same inexpensive Intel processors\nthat you have in your desktop machine.  And once you've written\nthe software, all you need to sell it is a Web site.  Nearly all\nour users came direct to our site through word of mouth and references\nin the press. [12]<br/><br/>Viaweb was a typical larval startup.  We were terrified of starting\na company, and for the first few months comforted ourselves by\ntreating the whole thing as an experiment that we might call off\nat any moment.  Fortunately, there were few obstacles except\ntechnical ones.  While we were writing the software, our Web server\nwas the same desktop machine we used for development, connected to\nthe outside world by a dialup line.  Our only expenses in that\nphase were food and rent.<br/><br/>There is all the more reason for startups to write Web-based software\nnow, because writing desktop software has become a lot less fun.\nIf you want to write desktop software now you do it on Microsoft's\nterms, calling their APIs and working around their buggy OS.  And\nif you manage to write something that takes off, you may find that\nyou were merely doing market research for Microsoft.<br/><br/>If a company wants to make a platform that startups will build on,\nthey have to make it something that hackers themselves will want\nto use.   That means it has to be inexpensive and well-designed.\nThe Mac was popular with hackers when it first came out, and a lot\nof them wrote software for it. [13] You see this less with Windows,\nbecause hackers don't use it.  The kind of people who are good at\nwriting software tend to be running Linux or FreeBSD now.<br/><br/>I don't think we would have started a startup to write desktop\nsoftware, because desktop software has to run on Windows, and before\nwe could write software for Windows we'd have to use it.  The Web \nlet us do an end-run around Windows, and deliver software running \non Unix direct to users through the browser.  That is a liberating \nprospect, a lot like the arrival of PCs twenty-five years ago.<br/><br/><b>Microsoft</b><br/><br/>Back when desktop computers arrived, IBM was the giant that everyone\nwas afraid of.  It's hard to imagine now, but I remember the feeling\nvery well.  Now the frightening giant is Microsoft, and I don't\nthink they are as blind to the threat facing them as IBM was.\nAfter all, Microsoft deliberately built their business in IBM's\nblind spot.<br/><br/>I mentioned earlier that my mother doesn't really need a desktop\ncomputer.  Most users probably don't.  That's a problem for Microsoft,\nand they know it.  If applications run on remote servers, no one\nneeds Windows.  What will Microsoft do?  Will they be able to use\ntheir control of the desktop to prevent, or constrain, this new\ngeneration of software?<br/><br/>My guess is that Microsoft will develop some kind of server/desktop\nhybrid, where the operating system works together with servers they\ncontrol.  At a minimum, files will be centrally available for users\nwho want that.  I don't expect Microsoft to go all the way to the\nextreme of doing the computations on the server, with only a browser\nfor a client, if they can avoid it. If you only need a browser for\na client, you don't need Microsoft on the client, and if Microsoft\ndoesn't control the client, they can't push users towards their\nserver-based applications.<br/><br/>I think Microsoft will have a hard time keeping the genie in the\nbottle.  There will be too many different types of clients for them\nto control them all.  And if Microsoft's applications only work\nwith some clients, competitors will be able to trump them by offering\napplications that work from any client. [14]<br/><br/>In a world of Web-based applications, there is no automatic place\nfor Microsoft.  They may succeed in making themselves a place, but\nI don't think they'll dominate this new world as they did the world\nof desktop applications.<br/><br/>It's not so much that a competitor will trip them up as that they\nwill trip over themselves.  With the rise of Web-based software,\nthey will be facing not just technical problems but their own\nwishful thinking.  What they need to do is cannibalize their existing\nbusiness, and I can't see them facing that.  The same single-mindedness\nthat has brought them this far will now be working against them.\nIBM was in exactly the same situation, and they could not master\nit.  IBM made a late and half-hearted entry into the microcomputer\nbusiness because they were ambivalent about threatening their cash\ncow, mainframe computing.  Microsoft will likewise be hampered by\nwanting to save the desktop.  A cash cow can be a damned heavy\nmonkey on your back.<br/><br/>I'm not saying that no one will dominate server-based applications.\nSomeone probably will eventually.  But I think that there will be\na good long period of cheerful chaos, just as there was in the\nearly days of microcomputers.  That was a good time for startups.\nLots of small companies flourished, and did it by making cool\nthings.<br/><br/><b>Startups but More So</b><br/><br/>The classic startup is fast and informal, with few people and little\nmoney.  Those few people work very hard, and technology magnifies\nthe effect of the decisions they make.  If they win, they win big.<br/><br/>In a startup writing Web-based applications, everything you associate\nwith startups is taken to an extreme.  You can write and launch a\nproduct with even fewer people and even less money.  You have to\nbe even faster, and you can get away with being more informal.\nYou can literally launch your product as three guys sitting in the\nliving room of an apartment, and a server collocated at an ISP.\nWe did.<br/><br/>Over time the teams have gotten smaller, faster, and more informal.\nIn 1960, software development meant a roomful of men with horn\nrimmed glasses and narrow black neckties, industriously writing\nten lines of code a day on IBM coding forms.  In 1980, it was a\nteam of eight to ten people wearing jeans to the office and typing\ninto vt100s.  Now it's a couple of guys sitting in a living room\nwith laptops.  (And jeans turn out not to be the last word in\ninformality.)<br/><br/>Startups are stressful, and this, unfortunately, is also taken to\nan extreme with Web-based applications.  \nMany software companies, especially at the beginning, have periods\nwhere the developers slept under their desks and so on.  The alarming\nthing about Web-based software is that there is nothing to prevent\nthis becoming the default.  The stories about sleeping under desks\nusually end:  then at last we shipped it and we all went home and\nslept for a week.  Web-based software never ships.  You can work\n16-hour days for as long as you want to.  And because you can, and\nyour competitors can, you tend to be forced to.  You can, so you\nmust.  It's Parkinson's Law running in reverse.<br/><br/>The worst thing is not the hours but the responsibility.  Programmers\nand system administrators traditionally each have their own separate\nworries.  Programmers have to worry about bugs, and system\nadministrators have to worry about infrastructure.  Programmers\nmay spend a long day up to their elbows in source code, but at some\npoint they get to go home and forget about it.  System administrators\nnever quite leave the job behind, but when they do get paged at\n4:00 AM, they don't usually have to do anything very complicated.\nWith Web-based applications, these two kinds of stress get combined.\nThe programmers become system administrators, but without the\nsharply defined limits that ordinarily make the job bearable.<br/><br/>At Viaweb we spent the first six months just writing software.  We\nworked the usual long hours of an early startup.  In a desktop\nsoftware company, this would have been the part where we were\nworking hard, but it felt like a vacation compared to the next\nphase, when we took users onto our server.  The second biggest\nbenefit of selling Viaweb to Yahoo (after the money) was to be able\nto dump ultimate responsibility for the whole thing onto the\nshoulders of a big company.<br/><br/>Desktop software forces users to become system administrators.\nWeb-based software forces programmers to.  There is less stress in\ntotal, but more for the programmers.  That's not necessarily bad\nnews.  If you're a startup competing with a big company, it's good\nnews. [15]  Web-based applications offer a straightforward way to\noutwork your competitors.  No startup asks for more.<br/><br/><b>Just Good Enough</b><br/><br/>One thing that might deter you from writing Web-based applications\nis the lameness of Web pages as a UI.  That is a problem, I admit.\nThere were a few things we would have <i>really</i> liked to add to\nHTML and HTTP.  What matters, though, is that Web pages are just\ngood enough.<br/><br/>There is a parallel here with the first microcomputers.  The\nprocessors in those machines weren't actually intended to be the\nCPUs of computers.  They were designed to be used in things like\ntraffic lights.  But guys like Ed Roberts, who designed the \n<a href=\"http://en.wikipedia.org/wiki/Altair_8800\">Altair</a>,\nrealized that they were just good enough.  You could combine one\nof these chips with some memory (256 bytes in the first Altair),\nand front panel switches, and you'd have a working computer.  Being\nable to have your own computer was so exciting that there were\nplenty of people who wanted to buy them, however limited.<br/><br/>Web pages weren't designed to be a UI for applications, but they're\njust good enough.  And for a significant number of users, software\nthat you can use from any browser will be enough of a win in itself\nto outweigh any awkwardness in the UI.  Maybe you can't write the\nbest-looking spreadsheet using HTML, but you can write a spreadsheet\nthat several people can use simultaneously from different locations\nwithout special client software, or that can incorporate live data\nfeeds, or that can page you when certain conditions are triggered.\nMore importantly, you can write new kinds of applications that\ndon't even have names yet.  VisiCalc was not merely a microcomputer\nversion of a mainframe application, after all-- it was a new type\nof application.<br/><br/>Of course, server-based applications don't have to be Web-based.\nYou could have some other kind of client.  But I'm pretty sure\nthat's a bad idea.  It would be very convenient if you could assume\nthat everyone would install your client-- so convenient that you\ncould easily convince yourself that they all would-- but if they\ndon't, you're hosed.  Because Web-based software assumes nothing\nabout the client, it will work anywhere the Web works.  That's a\nbig advantage already, and the advantage will grow as new Web\ndevices proliferate.  Users will like you because your software\njust works, and your life will be easier because you won't have to\ntweak it for every new client.  <!-- I would not even use Javascript,\nif I were you.  Viaweb didn't. --> [16]<br/><br/>I feel like I've watched the evolution of the Web as closely as\nanyone, and I can't predict what's going to happen with clients.\nConvergence is probably coming, but where?  I can't pick a winner.\nOne thing I can predict is conflict between AOL and Microsoft.\nWhatever Microsoft's .NET turns out to be, it will probably involve\nconnecting the desktop to servers.  Unless AOL fights back, they\nwill either be pushed aside or turned into a pipe between Microsoft\nclient and server software.  If Microsoft and AOL get into a client\nwar, the only thing sure to work on both will be browsing the Web,\nmeaning Web-based applications will be the only kind that work\neverywhere.<br/><br/>How will it all play out?  I don't know.  And you don't have to\nknow if you bet on Web-based applications.  No one can break that\nwithout breaking browsing.  The Web may not be the only way to\ndeliver software, but it's one that works now and will continue to\nwork for a long time.  Web-based applications are cheap to develop,\nand easy for even the smallest startup to deliver.  They're a lot\nof work, and of a particularly stressful kind, but that only makes\nthe odds better for startups.<br/><br/><b>Why Not?</b><br/><br/>E. B. White was amused to learn from a farmer friend that many\nelectrified fences don't have any current running through them.\nThe cows apparently learn to stay away from them, and after that\nyou don't need the current.  \"Rise up, cows!\" he wrote, \"Take your\nliberty while despots snore!\"<br/><br/>If you're a hacker who has thought of one day starting a startup,\nthere are probably two things keeping you from doing it.  One is\nthat you don't know anything about business.  The other is that\nyou're afraid of competition.  Neither of these fences have any\ncurrent in them.<br/><br/>There are only two things you have to know about business:  build\nsomething users love, and make more than you spend.  If you get\nthese two right, you'll be ahead of most startups.  You can figure\nout the rest as you go.<br/><br/>You may not at first make more than you spend, but as long as the\ngap is closing fast enough you'll be ok.  If you start out underfunded,\nit will at least encourage a habit of frugality.  The less you\nspend, the easier it is to make more than you spend.  Fortunately,\nit can be very cheap to launch a Web-based application.  We launched\non under $10,000, and it would be even cheaper today.  We had to\nspend thousands on a server, and thousands more to get SSL.  (The\nonly company selling SSL software at the time was Netscape.)  Now\nyou can rent a much more powerful server, with SSL included, for\nless than we paid for bandwidth alone.  You could launch a Web-based\napplication now for less than the cost of a fancy office chair.<br/><br/>As for building something users love, here are some general tips.\nStart by making something clean and simple that you would want to\nuse yourself.  Get a version 1.0 out fast, then continue to improve\nthe software, listening closely to the users as you do.  The customer\nis always right, but different customers are right about different\nthings; the least sophisticated users show you what you need to\nsimplify and clarify, and the most sophisticated tell you what\nfeatures you need to add. The best thing software can be is easy,\nbut the way to do this is to get the defaults right, not to limit\nusers' choices.  Don't get complacent if your competitors' software\nis lame; the standard to compare your software to is what it could\nbe, not what your current competitors happen to have.  Use your\nsoftware yourself, all the time.  Viaweb was supposed to be an\nonline store builder, but we used it to make our own site too.\nDon't listen to marketing people or designers or product managers\njust because of their job titles.  If they have good ideas, use\nthem, but it's up to you to decide; software has to be designed by\nhackers who understand design, not designers who know a little\nabout software.  If you can't design software as well as implement\nit, don't start a startup.<br/><br/>Now let's talk about competition.  What you're afraid of is not\npresumably groups of hackers like you, but actual companies, with\noffices and business plans and salesmen and so on, right?  Well,\nthey are more afraid of you than you are of them, and they're right.\nIt's a lot easier for a couple of hackers to figure out how to rent\noffice space or hire sales people than it is for a company of any\nsize to get software written.  I've been on both sides, and I know.\nWhen Viaweb was bought by Yahoo, I suddenly found myself working\nfor a big company, and it was like trying to run through waist-deep\nwater.<br/><br/>I don't mean to disparage Yahoo.  They had some good hackers, and\nthe top management were real butt-kickers.  For a big company, they\nwere exceptional.  But they were still only about a tenth as\nproductive as a small startup.  No big company can do much better\nthan that.  What's scary about Microsoft is that a company so\nbig can develop software at all.  They're like a mountain that\ncan walk.<br/><br/>Don't be intimidated.  You can do as much that Microsoft can't as\nthey can do that you can't.  And no one can stop you.  You don't\nhave to ask anyone's permission to develop Web-based applications.\nYou don't have to do licensing deals, or get shelf space in retail\nstores, or grovel to have your application bundled with the OS.\nYou can deliver software right to the browser, and no one can get\nbetween you and potential users without preventing them from browsing\nthe Web.<br/><br/>You may not believe it, but I promise you, Microsoft is scared of\nyou.  The complacent middle managers may not be, but Bill is,\nbecause he was you once, back in 1975, the last time a new way of\ndelivering software appeared.<br/><br/><br/><br/><br/><br/><b>Notes</b><br/><br/>[1] Realizing that much of the money is in the services, companies\nbuilding lightweight clients have usually tried to combine the\nhardware with an \n<a href=\"http://news.cnet.com/news/0-1006-200-3622600.html\">online service</a>. \n This approach has not worked\nwell, partly because you need two different kinds of companies to\nbuild consumer electronics and to run an online service, and partly\nbecause users hate the idea.  Giving away the razor and making\nmoney on the blades may work for Gillette, but a razor is much\nsmaller commitment than a Web terminal.  Cell phone handset makers\nare satisfied to sell hardware without trying to capture the service\nrevenue as well.  That should probably be the model for Internet\nclients too.  If someone just sold a nice-looking little box with\na Web browser that you could use to connect through any ISP, every\ntechnophobe in the country would buy one.<br/><br/>[2] Security always depends more on not screwing up than any design\ndecision, but the nature of server-based software will make developers\npay more attention to not screwing up.  Compromising a server could\ncause such damage that ASPs (that want to stay in business) are\nlikely to be careful about security.<br/><br/>[3] In 1995, when we started Viaweb, Java applets were supposed to\nbe the technology everyone was going to use to develop server-based\napplications.  Applets seemed to us an old-fashioned idea.  Download\nprograms to run on the client? Simpler just to go all the way and\nrun the programs on the server.  We wasted little time\non applets, but countless other startups must have been lured into\nthis tar pit.  Few can have escaped alive, or Microsoft could not\nhave gotten away with dropping Java in the most recent version of\nExplorer.<br/><br/>[4] This point is due to Trevor Blackwell, who adds \"the cost of\nwriting software goes up more than linearly with its size.  Perhaps\nthis is mainly due to fixing old bugs, and the cost can be more\nlinear if all bugs are found quickly.\"<br/><br/>[5] The hardest kind of bug to find may be a variant of compound\nbug where one bug happens to compensate for another.  When you fix\none bug, the other becomes visible.  But it will seem as if the\nfix is at fault, since that was the last thing you changed.<br/><br/>[6] Within Viaweb we once had a contest to describe the worst thing\nabout our software.  Two customer support people tied for first\nprize with entries I still shiver to recall.  We fixed both problems\nimmediately.<br/><br/>[7] Robert Morris wrote the ordering system, which shoppers used\nto place orders. Trevor Blackwell wrote the image generator and\nthe manager, which merchants used to retrieve orders, view statistics,\nand configure domain names etc.  I wrote the editor, which merchants\nused to build their sites.  The ordering system and image generator\nwere written in C and C++, the manager mostly in Perl, and the editor\nin <a href=\"avg.html\">Lisp</a>.<br/><br/>[8] Price discrimination is so pervasive (how often have you heard\na retailer claim that their buying power meant lower prices for\nyou?) that I was surprised to find it was outlawed in the U.S. by\nthe Robinson-Patman Act of 1936.  This law does not appear to be\nvigorously enforced.<br/><br/>[9] In <i>No Logo,</i> Naomi Klein says that clothing brands favored by\n\"urban youth\" do not try too hard to prevent shoplifting because\nin their target market the shoplifters are also the fashion leaders.<br/><br/>[10] Companies often wonder what to outsource and what not to.\nOne possible answer: outsource any job that's not directly exposed\nto competitive pressure, because outsourcing it will thereby expose\nit to competitive pressure.<br/><br/>[11] The two guys were Dan Bricklin and Bob Frankston.  Dan wrote\na prototype in Basic in a couple days, then over the course of the\nnext year they worked together (mostly at night) to make a more\npowerful version written in 6502 machine language.  Dan was at\nHarvard Business School at the time and Bob nominally had a day\njob writing software.  \"There was no great risk in doing a business,\"\nBob wrote, \"If it failed it failed. No big deal.\"<br/><br/>[12] It's not quite as easy as I make it sound.  It took a painfully\nlong time for word of mouth to get going, and we did not start to\nget a lot of press coverage until we hired a \n<a href=\"http://www.schwartz-pr.com\">PR firm</a> \n(admittedly\nthe best in the business) for $16,000 per month.  However, it was\ntrue that the only significant channel was our own Web site.<br/><br/>[13] If the Mac was so great, why did it lose?  Cost, again.\nMicrosoft concentrated on the software business, and unleashed a\nswarm of cheap component suppliers on Apple hardware.  It did not\nhelp, either, that suits took over during a critical period.<br/><br/>[14] One thing that would help Web-based applications, and help\nkeep the next generation of software from being overshadowed by\nMicrosoft, would be a good open-source browser.  Mozilla is\nopen-source but seems to have suffered from having been corporate\nsoftware for so long.  A small, fast browser that was actively\nmaintained would be a great thing in itself, and would probably\nalso encourage companies to build little Web appliances.<br/><br/>Among other things, a proper open-source browser would cause HTTP\nand HTML to continue to evolve (as e.g. Perl has).  It would help\nWeb-based applications greatly to be able to distinguish between\nselecting a link and following it; all you'd need to do this would\nbe a trivial enhancement of HTTP, to allow multiple urls in a\nrequest.  Cascading menus would also be good.<br/><br/>If you want to change the world, write a new Mosaic.  Think it's\ntoo late?  In 1998 a lot of people thought it was too late to launch\na new search engine, but Google proved them wrong.  There is always\nroom for something new if the current options suck enough.  Make\nsure it works on all the free OSes first-- new things start with\ntheir users.<br/><br/>[15] Trevor Blackwell, who probably knows more about this from\npersonal experience than anyone, writes:<br/><br/>\"I would go farther in saying that because server-based software\nis so hard on the programmers, it causes a fundamental economic\nshift away from large companies. It requires the kind of intensity\nand dedication from programmers that they will only be willing to\nprovide when it's their own company.  Software companies can hire\nskilled people to work in a not-too-demanding environment, and can\nhire unskilled people to endure hardships, but they can't hire\nhighly skilled people to bust their asses. Since capital is no\nlonger needed, big companies have little to bring to the table.\"<br/><br/>[16] In the original version of this essay, I advised avoiding\nJavascript.  That was a good plan in 2001, but Javascript now works.\n<!-- Most of the Javascript I see on the Web isn't necessary, and\nmuch of it breaks.  (My mental picture of a Javascript programmer\nis Wally from Dilbert, with a thought bubble over his head reading\n\"It works on my computer.\") Yahoo uses Javascript in a few places,\nthough not many.  I once asked someone there how this worked out,\nand he said \"they ended up learning a <i>lot</i> about different browser\nversions.\" Microsoft may start to embrace and extend Javascript,\nor even can it, like Java.  And when you start to be able to browse\nactual Web pages on your cell phone or PDA (or toaster), who knows\nif they'll even support it? --><br/><br/><b>Thanks</b> to Sarah Harlin, Trevor Blackwell, Robert Morris, Eric Raymond, Ken Anderson,\nand Dan Giffin for reading drafts of this paper; to Dan Bricklin and\nBob Frankston for information about VisiCalc; and again to Ken Anderson\nfor inviting me to speak at BBN.<br/><br/><table cellpadding=\"0\" cellspacing=\"0\" width=\"410\">\n<tr><td bgcolor=\"#ffe799\"><img height=\"15\" src=\"http://www.virtumundo.com/images/spacer.gif\" width=\"1\"/><font size=\"2\">\nYou'll find this essay and 14 others in\n<a href=\"hackpaint.html\"><b><i>Hackers &amp; Painters</i></b></a>.</font>\n<br/><img height=\"5\" src=\"http://www.virtumundo.com/images/spacer.gif\" width=\"1\"/></td><tr><br><br/></br></tr></tr></table></font>","date":"2001-09-01T00:00:00Z"}