{"href":"langdes.html","title":"Five Questions about Language Design","content":"<font face=\"verdana\" size=\"2\">May 2001\n<p>\n<i>(These are some notes I made\nfor a panel discussion on programming language design\nat MIT on May 10, 2001.)</i><br/><br/><br/><br/><img border=\"0\" height=\"18\" hspace=\"0\" src=\"https://s.turbifycdn.com/aah/paulgraham/five-questions-about-language-design-18.gif\" vspace=\"0\" width=\"159\"/><br/><br/><b>1. Programming Languages Are for People.</b><br/><br/>Programming languages\nare how people talk to computers.  The computer would be just as\nhappy speaking any language that was unambiguous.  The reason we\nhave high level languages is because people can't deal with\nmachine language.  The point of programming\nlanguages is to prevent our poor frail human brains from being \noverwhelmed by a mass of detail.<br/><br/>Architects know that some kinds of design problems are more personal\nthan others.  One of the cleanest, most abstract design problems\nis designing bridges.  There your job is largely a matter of spanning\na given distance with the least material.  The other end of the\nspectrum is designing chairs.  Chair designers have to spend their\ntime thinking about human butts.<br/><br/>Software varies in the same way. Designing algorithms for routing\ndata through a network is a nice, abstract problem, like designing\nbridges.  Whereas designing programming languages is like designing\nchairs: it's all about dealing with human weaknesses.<br/><br/>Most of us hate to acknowledge this.  Designing systems of great\nmathematical elegance sounds a lot more appealing to most of us\nthan pandering to human weaknesses.  And there is a role for mathematical\nelegance: some kinds of elegance make programs easier to understand.\nBut elegance is not an end in itself.<br/><br/>And when I say languages have to be designed to suit human weaknesses,\nI don't mean that languages have to be designed for bad programmers.\nIn fact I think you ought to design for the \n<a href=\"design.html\">best programmers</a>, but\neven the best programmers have limitations.  I don't think anyone\nwould like programming in a language where all the variables were\nthe letter x with integer subscripts.<br/><br/><b>2. Design for Yourself and Your Friends.</b><br/><br/>If you look at the history of programming languages, a lot of the best\nones were languages designed for their own authors to use, and a\nlot of the worst ones were designed for other people to use.<br/><br/>When languages are designed for other people, it's always a specific\ngroup of other people: people not as smart as the language designer.\nSo you get a language that talks down to you.  Cobol is the most\nextreme case, but a lot of languages are pervaded by this spirit.<br/><br/>It has nothing to do with how abstract the language is.  C is pretty\nlow-level, but it was designed for its authors to use, and that's\nwhy hackers like it.<br/><br/>The argument for designing languages for bad programmers is that\nthere are more bad programmers than good programmers.  That may be\nso.  But those few good programmers write a disproportionately\nlarge percentage of the software.<br/><br/>I'm interested in the question, how do you design a language that\nthe very best hackers will like?  I happen to think this is\nidentical to the question, how do you design a good programming\nlanguage?, but even if it isn't, it is at least an interesting\nquestion.<br/><br/><b>3. Give the Programmer as Much Control as Possible.</b><br/><br/>Many languages\n(especially the ones designed for other people) have the attitude\nof a governess: they try to prevent you from\ndoing things that they think aren't good for you.  I like the   \nopposite approach: give the programmer as much\ncontrol as you can.<br/><br/>When I first learned Lisp, what I liked most about it was\nthat it considered me an equal partner.  In the other languages\nI had learned up till then, there was the language and there was my   \nprogram, written in the language, and the two were very separate.\nBut in Lisp the functions and macros I wrote were just like those\nthat made up the language itself.  I could rewrite the language\nif I wanted.  It had the same appeal as open-source software.<br/><br/><b>4. Aim for Brevity.</b><br/><br/>Brevity is underestimated and even scorned.\nBut if you look into the hearts of hackers, you'll see that they\nreally love it.  How many times have you heard hackers speak fondly\nof how in, say, APL, they could do amazing things with just a couple\nlines of code?  I think anything that really smart people really\nlove is worth paying attention to.<br/><br/>I think almost anything\nyou can do to make programs shorter is good.  There should be lots\nof library functions; anything that can be implicit should be;\nthe syntax should be terse to a fault; even the names of things\nshould be short.<br/><br/>And it's not only programs that should be short.  The manual should\nbe thin as well.  A good part of manuals is taken up with clarifications\nand reservations and warnings and special cases.  If you force  \nyourself to shorten the manual, in the best case you do it by fixing\nthe things in the language that required so much explanation.<br/><br/><b>5. Admit What Hacking Is.</b><br/><br/>A lot of people wish that hacking was\nmathematics, or at least something like a natural science.  I think\nhacking is more like architecture.  Architecture is\nrelated to physics, in the sense that architects have to design\nbuildings that don't fall down, but the actual goal of architects\nis to make great buildings, not to make discoveries about statics.<br/><br/>What hackers like to do is make great programs.\nAnd I think, at least in our own minds, we have to remember that it's\nan admirable thing to write great programs, even when this work \ndoesn't translate easily into the conventional intellectual\ncurrency of research papers.  Intellectually, it is just as\nworthwhile to design a language programmers will love as it is to design a\nhorrible one that embodies some idea you can publish a paper\nabout.<br/><br/><br/><br/><img border=\"0\" height=\"18\" hspace=\"0\" src=\"https://s.turbifycdn.com/aah/paulgraham/five-questions-about-language-design-19.gif\" vspace=\"0\" width=\"125\"/><br/><br/><b>1. How to Organize Big Libraries?</b><br/><br/>Libraries are becoming an\nincreasingly important component of programming languages.  They're\nalso getting bigger, and this can be dangerous.  If it takes longer\nto find the library function that will do what you want than it\nwould take to write it yourself, then all that code is doing nothing\nbut make your manual thick.  (The Symbolics manuals were a case in \npoint.)  So I think we will have to work on ways to organize\nlibraries.  The ideal would be to design them so that the programmer\ncould guess what library call would do the right thing.<br/><br/><b>2. Are People Really Scared of Prefix Syntax?</b><br/><br/>This is an open\nproblem in the sense that I have wondered about it for years and\nstill don't know the answer.  Prefix syntax seems perfectly natural\nto me, except possibly for math.  But it could be that a lot of \nLisp's unpopularity is simply due to having an unfamiliar syntax.   \nWhether to do anything about it, if it is true, is another question. \n<p align=\"left\">\n<b>3. What Do You Need for Server-Based Software?</b>\n<p align=\"justif\">\nI think a lot of the most exciting new applications that get written\nin the next twenty years will be Web-based applications, meaning\nprograms that sit on the server and talk to you through a Web\nbrowser.  And to write these kinds of programs we may need some\nnew things.<br/><br/>One thing we'll need is support for the new way that server-based \napps get released.  Instead of having one or two big releases a\nyear, like desktop software, server-based apps get released as a\nseries of small changes.  You may have as many as five or ten\nreleases a day.  And as a rule everyone will always use the latest\nversion.<br/><br/>You know how you can design programs to be debuggable?\nWell, server-based software likewise has to be designed to be\nchangeable.  You have to be able to change it easily, or at least\nto know what is a small change and what is a momentous one.<br/><br/>Another thing that might turn out to be useful for server based\nsoftware, surprisingly, is continuations.  In Web-based software\nyou can use something like continuation-passing style to get the\neffect of <a href=\"lwba.html\">subroutines</a> in the inherently \nstateless world of a Web\nsession.  Maybe it would be worthwhile having actual continuations,\nif it was not too expensive.<br/><br/><b>4. What New Abstractions Are Left to Discover?</b><br/><br/>I'm not sure how\nreasonable a hope this is, but one thing I would really love to    \ndo, personally, is discover a new abstraction-- something that would\nmake as much of a difference as having first class functions or\nrecursion or even keyword parameters.  This may be an impossible\ndream.  These things don't get discovered that often.  But I am always\nlooking.<br/><br/><br/><br/><img border=\"0\" height=\"18\" hspace=\"0\" src=\"https://s.turbifycdn.com/aah/paulgraham/five-questions-about-language-design-20.gif\" vspace=\"0\" width=\"179\"/><br/><br/><b>1. You Can Use Whatever Language You Want.</b><br/><br/>Writing application\nprograms used to mean writing desktop software.  And in desktop\nsoftware there is a big bias toward writing the application in the\nsame language as the operating system.  And so ten years ago,\nwriting software pretty much meant writing software in C.\nEventually a tradition evolved:\napplication programs must not be written in unusual languages.  \nAnd this tradition had so long to develop that nontechnical people\nlike managers and venture capitalists also learned it.<br/><br/>Server-based software blows away this whole model.  With server-based\nsoftware you can use any language you want.  Almost nobody understands\nthis yet (especially not managers and venture capitalists).\nA few hackers understand it, and that's why we even hear\nabout new, indy languages like Perl and Python.  We're not hearing\nabout Perl and Python because people are using them to write Windows\napps.<br/><br/>What this means for us, as people interested in designing programming\nlanguages, is that there is now potentially an actual audience for\nour work.<br/><br/><b>2. Speed Comes from Profilers.</b><br/><br/>Language designers, or at least\nlanguage implementors, like to write compilers that generate fast\ncode.  But I don't think this is what makes languages fast for users.\nKnuth pointed out long ago that speed only matters in a few critical\nbottlenecks.  And anyone who's tried it knows that you can't guess\nwhere these bottlenecks are.  Profilers are the answer.<br/><br/>Language designers are solving the wrong problem.  Users don't need\nbenchmarks to run fast.  What they need is a language that can show\nthem what parts of their own programs need to be rewritten.  That's\nwhere speed comes from in practice.  So maybe it would be a net \nwin if language implementors took half the time they would\nhave spent doing compiler optimizations and spent it writing a\ngood profiler instead.<br/><br/><b>3. You Need an Application to Drive the Design of a Language.</b><br/><br/>This may not be an absolute rule, but it seems like the best languages\nall evolved together with some application they were being used to\nwrite.  C was written by people who needed it for systems programming.\nLisp was developed partly to do symbolic differentiation, and\nMcCarthy was so eager to get started that he was writing differentiation\nprograms even in the first paper on Lisp, in 1960.<br/><br/>It's especially good if your application solves some new problem.\nThat will tend to drive your language to have new features that   \nprogrammers need.  I personally am interested in writing\na language that will be good for writing server-based applications.<br/><br/>[During the panel, Guy Steele also made this point, with the\nadditional suggestion that the application should not consist of\nwriting the compiler for your language, unless your language\nhappens to be intended for writing compilers.]<br/><br/><b>4. A Language Has to Be Good for Writing Throwaway Programs.</b><br/><br/>You know what a throwaway program is: something you write quickly for\nsome limited task.  I think if you looked around you'd find that  \na lot of big, serious programs started as throwaway programs.  I\nwould not be surprised if <i>most</i> programs started as throwaway\nprograms.  And so if you want to make a language that's good for\nwriting software in general, it has to be good for writing throwaway\nprograms, because that is the larval stage of most software.<br/><br/><b>5. Syntax Is Connected to Semantics.</b><br/><br/>It's traditional to think of\nsyntax and semantics as being completely separate.  This will\nsound shocking, but it may be that they aren't.\nI think that what you want in your language may be related\nto how you express it.<br/><br/>I was talking recently to Robert Morris, and he pointed out that\noperator overloading is a bigger win in languages with infix\nsyntax.  In a language with prefix syntax, any function you define\nis effectively an operator.  If you want to define a plus for a\nnew type of number you've made up, you can just define a new function\nto add them.  If you do that in a language with infix syntax,\nthere's a big difference in appearance between the use of an\noverloaded operator and a function call.<br/><br/><br/><br/><img border=\"0\" height=\"18\" hspace=\"0\" src=\"https://s.turbifycdn.com/aah/paulgraham/five-questions-about-language-design-21.gif\" vspace=\"0\" width=\"254\"/><br/><br/><b>1. New Programming Languages.</b><br/><br/>Back in the 1970s\nit was fashionable to design new programming languages.  Recently\nit hasn't been.  But I think server-based software will make new  \nlanguages fashionable again.  With server-based software, you can\nuse any language you want, so if someone does design a language that\nactually seems better than others that are available, there will be\npeople who take a risk and use it.<br/><br/><b>2. Time-Sharing.</b><br/><br/>Richard Kelsey gave this as an idea whose time\nhas come again in the last panel, and I completely agree with him.\nMy guess (and Microsoft's guess, it seems) is that much computing\nwill move from the desktop onto remote servers.  In other words,  \ntime-sharing is back.  And I think there will need to be support\nfor it at the language level.  For example, I know that Richard\nand Jonathan Rees have done a lot of work implementing process  \nscheduling within Scheme 48.<br/><br/><b>3. Efficiency.</b><br/><br/>Recently it was starting to seem that computers\nwere finally fast enough.  More and more we were starting to hear\nabout byte code, which implies to me at least that we feel we have\ncycles to spare.  But I don't think we will, with server-based\nsoftware.   Someone is going to have to pay for the servers that\nthe software runs on, and the number of users they can support per\nmachine will be the divisor of their capital cost.<br/><br/>So I think efficiency will matter, at least in computational\nbottlenecks.  It will be especially important to do i/o fast,\nbecause server-based applications do a lot of i/o.<br/><br/>It may turn out that byte code is not a win, in the end.  Sun and\nMicrosoft seem to be facing off in a kind of a battle of the byte\ncodes at the moment.  But they're doing it because byte code is a\nconvenient place to insert themselves into the process, not because\nbyte code is in itself a good idea.  It may turn out that this\nwhole battleground gets bypassed.  That would be kind of amusing.<br/><br/><br/><br/><img border=\"0\" height=\"18\" hspace=\"0\" src=\"https://s.turbifycdn.com/aah/paulgraham/five-questions-about-language-design-22.gif\" vspace=\"0\" width=\"170\"/><br/><br/><b>1. Clients.</b><br/><br/>This is just a guess, but my guess is that\nthe winning model for most applications will be purely server-based.\nDesigning software that works on the assumption that everyone will \nhave your client is like designing a society on the assumption that\neveryone will just be honest.  It would certainly be convenient, but\nyou have to assume it will never happen.<br/><br/>I think there will be a proliferation of devices that have some\nkind of Web access, and all you'll be able to assume about them is\nthat they can support simple html and forms.  Will you have a\nbrowser on your cell phone?  Will there be a phone in your palm  \npilot?  Will your blackberry get a bigger screen? Will you be able\nto browse the Web on your gameboy?  Your watch?  I don't know.  \nAnd I don't have to know if I bet on\neverything just being on the server.  It's\njust so much more robust to have all the \n<a href=\"road.html\">brains on the server</a>.<br/><br/><b>2. Object-Oriented Programming.</b><br/><br/>I realize this is a\ncontroversial one, but I don't think object-oriented programming\nis such a big deal.  I think it is a fine model for certain kinds\nof applications that need that specific kind of data structure,   \nlike window systems, simulations, and cad programs.  But I don't\nsee why it ought to be the model for all programming.<br/><br/>I think part of the reason people in big companies like object-oriented\nprogramming is because it yields a lot of what looks like work.\nSomething that might naturally be represented as, say, a list of\nintegers, can now be represented as a class with all kinds of\nscaffolding and hustle and bustle.<br/><br/>Another attraction of\nobject-oriented programming is that methods give you some of the\neffect of first class functions.  But this is old news to Lisp\nprogrammers.  When you have actual first class functions, you can\njust use them in whatever way is appropriate to the task at hand,\ninstead of forcing everything into a mold of classes and methods.<br/><br/>What this means for language design, I think, is that you shouldn't\nbuild object-oriented programming in too deeply.  Maybe the\nanswer is to offer more general, underlying stuff, and let people design\nwhatever object systems they want as libraries.<br/><br/><b>3. Design by Committee.</b><br/><br/>Having your language designed by a committee is a big pitfall,  \nand not just for the reasons everyone knows about.  Everyone\nknows that committees tend to yield lumpy, inconsistent designs.  \nBut I think a greater danger is that they won't take risks.\nWhen one person is in charge he can take risks\nthat a committee would never agree on.<br/><br/>Is it necessary to take risks to design a good language though?\nMany people might suspect\nthat language design is something where you should stick fairly\nclose to the conventional wisdom.  I bet this isn't true.\nIn everything else people do, reward is proportionate to risk.\nWhy should language design be any different?<br/><br/></p></p></p></font>","date":"2001-05-01T00:00:00Z"}