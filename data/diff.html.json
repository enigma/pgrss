{"href":"diff.html","title":"What Made Lisp Different","content":"<font face=\"verdana\" size=\"2\">December 2001 (rev. May 2002)\n<p align=\"justif\">\n<i>(This article came about in response to some questions on\nthe <a href=\"http://ll1.mit.edu\">LL1</a> mailing list.  It is now\nincorporated in <a href=\"https://paulgraham.com/icad.html\">Revenge of the Nerds</a>.)</i><br/><br/>When McCarthy designed Lisp in the late 1950s, it was\na radical departure from existing languages,\nthe most important of which was <a href=\"https://paulgraham.com/history.html\">Fortran</a>.<br/><br/>Lisp embodied nine new ideas:<br/><br/><hr/>\n<b>1. Conditionals.</b>  A conditional is an if-then-else\nconstruct.  We take these for granted now.  They were \n<a href=\"http://www-formal.stanford.edu/jmc/history/lisp/node2.html\">invented</a>\nby McCarthy in the course of developing Lisp. \n(Fortran at that time only had a conditional\ngoto, closely based on the branch instruction in the \nunderlying hardware.)  McCarthy, who was on the Algol committee, got\nconditionals into Algol, whence they spread to most other\nlanguages.<br/><br/><b>2. A function type.</b> In Lisp, functions are first class \nobjects-- they're a data type just like integers, strings,\netc, and have a literal representation, can be stored in variables,\ncan be passed as arguments, and so on.<br/><br/><b>3. Recursion.</b>  Recursion existed as a mathematical concept\nbefore Lisp of course, but Lisp was the first programming language to support\nit.  (It's arguably implicit in making functions first class\nobjects.)<br/><br/><b>4. A new concept of variables.</b>  In Lisp, all variables\nare effectively pointers. Values are what\nhave types, not variables, and assigning or binding\nvariables means copying pointers, not what they point to.<br/><br/><b>5. Garbage-collection.</b><br/><br/><b>6. Programs composed of expressions.</b> Lisp programs are \ntrees of expressions, each of which returns a value.  \n(In some Lisps expressions\ncan return multiple values.)  This is in contrast to Fortran\nand most succeeding languages, which distinguish between\nexpressions and statements.<br/><br/>It was natural to have this\ndistinction in Fortran because (not surprisingly in a language\nwhere the input format was punched cards) the language was\nline-oriented.  You could not nest statements.  And\nso while you needed expressions for math to work, there was\nno point in making anything else return a value, because\nthere could not be anything waiting for it.<br/><br/>This limitation\nwent away with the arrival of block-structured languages,\nbut by then it was too late. The distinction between\nexpressions and statements was entrenched.  It spread from \nFortran into Algol and thence to both their descendants.<br/><br/>When a language is made entirely of expressions, you can\ncompose expressions however you want.  You can say either\n(using <a href=\"https://paulgraham.com/arc.html\">Arc</a> syntax)<br/><br/>(if foo (= x 1) (= x 2))<br/><br/>or<br/><br/>(= x (if foo 1 2))<br/><br/><b>7. A symbol type.</b>  Symbols differ from strings in that\nyou can test equality by comparing a pointer.<br/><br/><b>8. A notation for code</b> using trees of symbols.<br/><br/><b>9. The whole language always available.</b>  \nThere is\nno real distinction between read-time, compile-time, and runtime.\nYou can compile or run code while reading, read or run code\nwhile compiling, and read or compile code at runtime.<br/><br/>Running code at read-time lets users reprogram Lisp's syntax;\nrunning code at compile-time is the basis of macros; compiling\nat runtime is the basis of Lisp's use as an extension\nlanguage in programs like Emacs; and reading at runtime\nenables programs to communicate using s-expressions, an\nidea recently reinvented as XML.\n<hr/><br/><br/>When Lisp was first invented, all these ideas were far\nremoved from ordinary programming practice, which was\ndictated largely by the hardware available in the late 1950s.<br/><br/>Over time, the default language, embodied\nin a succession of popular languages, has\ngradually evolved toward Lisp.  1-5 are now widespread.\n6 is starting to appear in the mainstream.\nPython has a form of 7, though there doesn't seem to be\nany syntax for it.  \n8, which (with 9) is what makes Lisp macros\npossible, is so far still unique to Lisp,\nperhaps because (a) it requires those parens, or something \njust as bad, and (b) if you add that final increment of power, \nyou can no \nlonger claim to have invented a new language, but only\nto have designed a new dialect of Lisp ; -)<br/><br/>Though useful to present-day programmers, it's\nstrange to describe Lisp in terms of its\nvariation from the random expedients other languages\nadopted.  That was not, probably, how McCarthy\nthought of it.  Lisp wasn't designed to fix the mistakes\nin Fortran; it came about more as the byproduct of an\nattempt to <a href=\"https://paulgraham.com/rootsoflisp.html\">axiomatize computation</a>.<br/><br/><!-- Nor is this a complete list of ideas that began with Lisp\nand spread to other languages.  These are only the initial\nset.  Several more were developed in successive Lisp\nimplementations, including continuations, \nmultiple return values, rest parameters,\nand assignment (setf) inversion. --><br/><br/></p></font>","date":"2001-12-01T00:00:00Z"}